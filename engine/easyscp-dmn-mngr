#!/usr/bin/perl

# EasySCP a Virtual Hosting Control Panel
# Copyright (C) 2001-2006 by moleSoftware GmbH - http://www.molesoftware.com
# Copyright (C) 2006-2010 by isp Control Panel - http://ispcp.net
# Copyright (C) 2010-2013 by Easy Server Control Panel - http://www.easyscp.net
#
# Version: $Id$
#
# The contents of this file are subject to the Mozilla Public License
# Version 1.1 (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
# License for the specific language governing rights and limitations
# under the License.
#
# The Original Code is "VHCS - Virtual Hosting Control System".
#
# The Initial Developer of the Original Code is moleSoftware GmbH.
# Portions created by Initial Developer are Copyright (C) 2001-2006
# by moleSoftware GmbH. All Rights Reserved.
#
# Portions created by the ispCP Team are Copyright (C) 2006-2010 by
# isp Control Panel. All Rights Reserved.
#
# Portions created by the EasySCP Team are Copyright (C) 2010-2012 by
# Easy Server Control Panel. All Rights Reserved.

################################################################################
## Program Short Desciption:                                                  ##
##  Domain Manager - Manage all data related to one domain                    ##
################################################################################

use FindBin;
use lib "$FindBin::Bin/";

require 'easyscp_common_code.pl';

use strict;
use warnings;

$main::dmn_task_id = undef;

# Default status set after domain name change action
$main::after_change_status = 'ok';

################################################################################
##                                SUBROUTINES                                 ##
################################################################################

################################################################################
##
## Start Up!
##
sub dmn_mngr_start_up {

	push_el(\@main::el, 'dmn_mngr_start_up()', 'Starting...');

	my $rs;

	# Checking for master process
	$rs = check_master();
	return $rs if ($rs != 0);

	# Clear Execution Logs, if any
	if (-e $main::easyscp_dmn_mngr_el) {
		$rs = del_file($main::easyscp_dmn_mngr_el);
		return $rs if ($rs != 0);
	}

	# Get task id
	$main::dmn_task_id = $ARGV[0];

	push_el(\@main::el, 'dmn_mngr_start_up()', 'Ending...');

	0;
}

################################################################################
##
## Shut Down!
##
sub dmn_mngr_shut_down {

	push_el(\@main::el, 'dmn_mngr_shut_down()', 'Starting...');
	push_el(\@main::el, 'dmn_mngr_shut_down()', 'Ending...');

	0;
}

################################################################################
##                             DNS data managment                             ##
################################################################################

################################################################################
##
## Adds domain main DNS configuration entries in (eg. /etc/bind/named.conf)
##
## @param $data Ref to an array that contains domain data
## @access private
##
sub _dmn_add_named_cfg_data {

	push_el(\@main::el, 'dmn_add_named_cfg_data()', 'Starting...');

	my ($data) = @_;

	if (!defined($data) || $data eq '') {
		push_el(
			\@main::el,
			'dmn_add_named_cfg_data()', 'FATAL: Undefined Input Data...'
		);

		return -1;
	}

	my ($rs, $cmd, $wrk_file);
	my $zone_name = @$data[1];

	# Directories paths
	my $cfg_dir = "$main::cfg{'CONF_DIR'}/bind";
	my $tpl_dir = "$cfg_dir/parts";
	my $wrk_dir = "$cfg_dir/working";

	# Load the working file from tpl directory (eg. /etc/easyscp/bind/working/)
	($rs, $wrk_file) = get_file("$wrk_dir/named.conf");
	return $rs if ($rs != 0);

	## Load all needed templates from (eg. /etc/easyscp/bind/parts/) - Begin

	my ($dta_b, $dta_e, $entry_b, $entry_e, $entry) = ('', '', '', '', '');

	# Gets all needed templates
	($rs, $dta_b, $dta_e, $entry_b, $entry_e, $entry) = get_tpl(
		$tpl_dir, 'cfg_dta_b.tpl', 'cfg_dta_e.tpl', 'cfg_entry_b.tpl',
		'cfg_entry_e.tpl', 'cfg_entry.tpl'
	);
	return $rs if ($rs != 0);

	## Load all needed template from (eg. /etc/easyscp/bind/parts/) - End

	## Construct needed tags and entries - Begin

	# Tags Preparation
	my %tag_hash = (
		'{DMN_NAME}' => $zone_name,
		'{DB_DIR}' => $main::cfg{'BIND_DB_DIR'}
	);

	# Entries Preparation
	my ($entry_b_val, $entry_e_val, $entry_val) = ('', '', '');

	($rs, $entry_b_val, $entry_e_val, $entry_val) = prep_tpl(
		\%tag_hash, $entry_b, $entry_e, $entry
	);
	return $rs if ($rs != 0);

	## Construct needed tags and entries - End

	## Build the new file - Begin

	# Checks if the file contains all main tags needed
	# TODO: Recovery process - Add it if doesn't exist
	($rs, undef) = get_tag($dta_b, $dta_e, $wrk_file);
	return $rs if ($rs != 0);

	# Removes the entries related to the domain if it exist
	($rs, $wrk_file) = del_tag($entry_b_val, "$entry_e_val\n", $wrk_file);
	return $rs if ($rs != 0 && $rs != -5);

	# Build the replacement entries
	my $entry_repl = "$entry_b_val$entry_val$entry_e_val\n$entry_b$entry_e";

	# Add new entries
	($rs, $wrk_file) = repl_tag(
	 	$entry_b, $entry_e, $wrk_file, $entry_repl, 'dmn_add_named_cfg_data'
	);
	return $rs if ($rs != 0);

	# Checks if the file contains all needed tags for futur entries
	# TODO: Recovery process - Add it if doesn't exist
	# FIXME Really needed ? Because can only occur if the above call
	# of repl_tag() fail, and if that fail, the present code will never run
	($rs, undef) = get_tag($entry_b, $entry_e, $wrk_file);
	return $rs if ($rs != 0);

	## Build the new file - End

	## Storage and installation of the new file  - Begin

	# Store the new file in working directory
	$rs = store_file(
		"$wrk_dir/named.conf", $wrk_file, $main::cfg{'ROOT_USER'},
		$main::cfg{'ROOT_GROUP'}, 0644
	);
	return $rs if ($rs != 0);

	# Install the new file in production directory
	$cmd = "$main::cfg{'CMD_CP'} -pf $wrk_dir/named.conf " .
		"$main::cfg{'BIND_CONF_FILE'}";

	$rs = sys_command_rs($cmd);
	return $rs if ($rs != 0);

	## Storage and installation of the new file  - End

	push_el(\@main::el, 'dmn_add_named_cfg_data()', 'Ending...');

	0;
}

################################################################################
##
## Deletes domain main DNS configuration entries from (eg. /etc/bind/named.conf)
##
## @param   $data Ref to an array that contains domain data
## @access  private
##
sub _dmn_del_named_cfg_data {

	push_el(\@main::el, 'dmn_del_named_cfg_data()', 'Starting...');

	my ($data) = @_;

	if (!defined($data) || $data eq '') {
		push_el(
			\@main::el, 'dmn_del_named_cfg_data()',
			'FATAL: Undefined Input Data...'
		);

		return -1;
	}

	my ($rs, $cmd, $wrk_file);
	my $zone_name = @$data[1];

	# Directories paths
	my $cfg_dir = "$main::cfg{'CONF_DIR'}/bind";
	my $tpl_dir = "$cfg_dir/parts";
	my $wrk_dir = "$cfg_dir/working";

	# Load the working file from tpl directory (eg. /etc/easyscp/bind/working/)
	($rs, $wrk_file) = get_file("$wrk_dir/named.conf");
	return $rs if ($rs != 0);

	## Load all needed templates from (eg. /etc/easyscp/bind/parts/) - Begin

	my ($dta_b, $dta_e, $entry_b, $entry_e, $entry) = ('', '', '', '', '');

	# Gets all needed templates
	($rs, $dta_b, $dta_e, $entry_b, $entry_e, $entry) = get_tpl(
		$tpl_dir, 'cfg_dta_b.tpl', 'cfg_dta_e.tpl', 'cfg_entry_b.tpl',
		'cfg_entry_e.tpl', 'cfg_entry.tpl'
	);
	return $rs if ($rs != 0);

	## Load all needed template from (eg. /etc/easyscp/bind/parts/) - End

	## Build needed tags and entries - Begin

	# Tags Preparation
	my %tag_hash = (
		'{DMN_NAME}' => $zone_name,
		'{DB_DIR}' => $main::cfg{'BIND_DB_DIR'}
	);

	# Entries Preparation
	my ($entry_b_val, $entry_e_val, $entry_val) = ('', '', '');

	($rs, $entry_b_val, $entry_e_val, $entry_val ) = prep_tpl(
		\%tag_hash, $entry_b, $entry_e, $entry
	);
	return $rs if ($rs != 0);

	## Build needed tags and entries - End

	## Build the new file - Begin

	# Checks if the file contains all main tags needed
	# TODO: Recovery process - Add it if doesn't exist
	($rs, undef) = get_tag($dta_b, $dta_e, $wrk_file);
	return $rs if ($rs != 0);

	# Removes the entries related to the domain if it exist
	($rs, $wrk_file) = del_tag($entry_b_val, "$entry_e_val\n", $wrk_file);
	return $rs if ($rs != 0 && $rs != -5);

	# Avoid work if the entries doesn't exist
	if($rs == -5) {
		push_el(
			\@main::el, 'dmn_del_named_cfg_data()',
			'WARNING: Entries were not found ! Aborting...'
		);

		return 0;
	}

	# Checks if the file contains all needed tags for futur entries
	# TODO: Recovery process - Add it if doesn't exist
	($rs, undef) = get_tag($entry_b, $entry_e, $wrk_file);
	return $rs if ($rs != 0);

	## Build the new file - End

	## Storage and installation of the new file  - Begin

	# Store the new file in working directory
	$rs = store_file(
		"$wrk_dir/named.conf", $wrk_file, $main::cfg{'ROOT_USER'},
		$main::cfg{'ROOT_GROUP'}, 0644
	);
	return $rs if ($rs != 0);

	# Install the new file in production directory
	$cmd = "$main::cfg{'CMD_CP'} -pf $wrk_dir/named.conf " .
		"$main::cfg{'BIND_CONF_FILE'}";

	$rs = sys_command_rs($cmd);
	return $rs if ($rs != 0);

	## Storage and installation of the new file  - End

	push_el(\@main::el, 'dmn_del_named_cfg_data()', 'Ending...');

	0;
}

################################################################################
##
## Create domain DNS zone file in (eg. /var/cache/bind)
##
## @param   arrayref $data Ref to an array that contains domain data
## @access  private
## @return  int 0 on success
sub _dmn_add_named_db_data {

	push_el(\@main::el, '_dmn_add_named_db_data()', 'Starting...');

	my ($data) = @_;

	if (!defined($data) || $data eq '') {
		push_el(
			\@main::el, '_dmn_add_named_db_data()',
			'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	# Get needed data
	my $rs;
	my $dmnStatus = @$data[13];
	my ($dmnName, $dmnIp) = (@$data[1], @$data[21]);
	my $baseServerIp = $main::cfg{'BASE_SERVER_IP'};
	my $slaveDnsIp = $main::cfg{'SECONDARY_DNS'};

	# Get needed templates
	my ($tplDbEntries);
	($rs, $tplDbEntries) = get_file(
		"$main::cfg{'CONF_DIR'}/bind/parts/db_e.tpl"
	);
	return $rs if($rs != 0);

	# Prepare templates
	($rs, $tplDbEntries) = prep_tpl(
		{
			'{DMN_NAME}' => $dmnName,
			'{DMN_IP}' => $dmnIp,
			'{BASE_SERVER_IP}' => $baseServerIp,
			'{SECONDARY_DNS_IP}' => ($slaveDnsIp ne '') ? $slaveDnsIp : $dmnIp
		},
		$tplDbEntries
	);
	return $rs if($rs != 0);

	my $wrkFile;

	if($dmnStatus ne 'toadd') {
		($rs, $wrkFile) = get_file(
			"$main::cfg{'CONF_DIR'}/bind/working/$dmnName.db"
		);
		return $rs if ($rs != 0);

		# Restore all defined sub entries if any exists

		my ($subBeginTag, $subEndTag);
		($rs, $subBeginTag, $subEndTag)= get_tpl(
			"$main::cfg{'CONF_DIR'}/bind/parts", 'db_sub_entry_b.tpl',
			'db_sub_entry_e.tpl'
		);
		return $rs if ($rs != 0);

		if($wrkFile =~ /(; sub \[.+?$dmnName\].*?\n[\d\D]+)\Q$subBeginTag\E/) {
			($rs, $tplDbEntries) = add_tag(
				$subBeginTag, $subEndTag, $tplDbEntries, $1
			);
			return $rs if($rs != 0);
		}
	} else {
		$wrkFile = \$tplDbEntries;
	}

	# Create or Update serial number according RFC 1912
	$rs = getSerialNumber(\$dmnName, \$tplDbEntries, \$wrkFile);
	return $rs if ($rs != 0);

	# Custom DNS support - Begin

	if($dmnStatus eq 'dnschange' || $dmnStatus eq 'change') {

		my $sql = "
			SELECT
				`domain_dns_id`, `domain_id`, `alias_id`, `domain_dns`,
				`domain_text`, `domain_class`, `domain_type`
			FROM
				`domain_dns`
			WHERE
				`domain_dns`.`alias_id` = 0
			AND
				`domain_dns`.`domain_id` = @${data[0]}
			ORDER BY
				`domain_dns_id`
			;
		";

		my $rows;

		($rs, $rows) = doSQL($sql);
		return $rs if ($rs != 0);

		if (@$rows > 0) {

			# Get needed templates for custom dns entries - Begin
			my ($tplDnsEntryB, $tplDnsEntry, $tplDnsEntryE);
			($rs, $tplDnsEntryB, $tplDnsEntry, $tplDnsEntryE) = get_tpl(
				"$main::cfg{'CONF_DIR'}/bind/parts", 'db_dns_entry_b.tpl',
				'db_dns_entry.tpl', 'db_dns_entry_e.tpl'
			);
			return $rs if($rs != 0);

			my ($dnsEntryBv, $dnsEntryV, $dnsEntryEv, $dnsEntries);

			foreach (@$rows) {

				# Variables replacement
				($rs, $dnsEntryBv, $dnsEntryV, $dnsEntryEv) = prep_tpl(
					{
						'{MANUAL_DNS_NAME}' => $_->[3],
						'{MANUAL_DNS_ID}' => $_->[0],
						'{MANUAL_DNS_DATA}' => $_->[4],
						'{MANUAL_DNS_CLASS}' => $_->[5],
						'{MANUAL_DNS_TYPE}' => $_->[6]
					},
					$tplDnsEntryB, $tplDnsEntry, $tplDnsEntryE
				);

				# Concatenates custom DNS entries
				$dnsEntries .= "$dnsEntryBv$dnsEntryV$dnsEntryEv\n";
			}

			# Put the custom DNS entries in db zone file
			($rs, $tplDbEntries) = add_tag(
				$tplDnsEntryB, $tplDnsEntryE, $tplDbEntries, $dnsEntries
			);
			return $rs if($rs != 0);
		}
	}

	# Custom DNS support - End

	# Install new domain db file
	foreach("$main::cfg{'CONF_DIR'}/bind/working", $main::cfg{'BIND_DB_DIR'}) {
		$rs = store_file(
			"$_/$dmnName.db", $tplDbEntries, $main::cfg{'ROOT_USER'},
			$main::cfg{'ROOT_GROUP'}, 0644
		);
		return $rs if($rs != 0);
	}

	push_el(\@main::el, 'dmn_add_named_db_data()', 'Ending...');

	0;
}

################################################################################
##
## Deletes domain DNS zone file from (eg. /var/cache/bind)
##
## @param   $data Ref to an array that contains domain data
## @access  private
## @return  int 0 on sucess
sub _dmn_del_named_db_data {

	push_el(\@main::el, 'dmn_del_named_db_data()', 'Starting...');

	my ($data) = @_;

	if (!defined($data) || $data eq '') {
		push_el(
			\@main::el, 'dmn_del_named_db_data()',
			'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my $rs;
	my $zone_file = @$data[1] . '.db';
	my $wrk_zone_file = "$main::cfg{'CONF_DIR'}/bind/working/$zone_file";
	my $sys_zone_file = "$main::cfg{'BIND_DB_DIR'}/$zone_file";

	# Remove working domain zone file if exists
	if(-e $wrk_zone_file) {
		$rs = del_file($wrk_zone_file);
		return $rs if ($rs != 0);
	}

	# Remove domain production zone file if exists
	if(-e $sys_zone_file) {
		$rs = del_file($sys_zone_file);
		return $rs if ($rs != 0);
	}

	push_el(\@main::el, 'dmn_del_named_db_data()', 'Ending...');

	0;
}

################################################################################
##
## Add DNS record in master db file for customer domain alias
##
## @author  Laurent Declercq <laurent.declercq@ispcp.net>
## @since   1.0.7
## @fix     #2388
## @access  private
## @param   arrayref $data Ref. to an array that contains domain data
## @return  int 0 on success
sub _add_customer_master_dmn_als_db_data {

	push_el(\@main::el, '_add_customer_master_dmn_als_db_data()', 'Starting...');

	my ($data) = @_;

	if (!defined($data) || $data eq '') {
		push_el(
			\@main::el, '_add_customer_master_dmn_als_db_data()',
			'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my ($rs, $cmd);
	my $wrk_dir = "$main::cfg{'CONF_DIR'}/bind/working";
	my $bkp_dir = "$main::cfg{'CONF_DIR'}/bind/backup";
	my $wrk_file = "$main::cfg{'BASE_SERVER_VHOST'}.db";

	# Get the current working file
	my $master_db_file_content;

	($rs, $master_db_file_content) = get_file("$wrk_dir/$wrk_file");
	return $rs if($rs != 0);

	# On toadd mode, domain_uid field is not set
	if(@$data[3] == 0) {
		$data->[3] = get_dmn_suexec_user(@$data[0]);
	}

	# Entry to be add
	my $entry = "$main::cfg{'APACHE_SUEXEC_USER_PREF'}@${data[3]}\t\tIN\t\tA\t" .
		"@$data[21]\n";

	# Prevents double entries
	$master_db_file_content =~ s/$entry//;

	# Add entry
	$master_db_file_content =~ s/(; ctm[\w ]+END\.\n)/$entry$1/;

	# Update serial number according RFC 1912
	# Todo: Add small workaround to avoid to regenerated serial X time during
	# update
	$rs = getSerialNumber(
		\$main::cfg{'BASE_SERVER_VHOST'}, \$master_db_file_content,
		\$master_db_file_content
	);
	return $rs if ($rs != 0);

	# Backup current working file
	$cmd = "$main::cfg{'CMD_CP'} -p $wrk_dir/$wrk_file $bkp_dir/$wrk_file" . time;

	$rs = sys_command_rs($cmd);
	return $rs if ($rs != 0);

	# Store the new file in working directory
	$rs = store_file(
		"$wrk_dir/$wrk_file", $master_db_file_content, $main::cfg{'ROOT_USER'},
		$main::cfg{'ROOT_GROUP'}, 0644
	);
	return $rs if ($rs != 0);

	# Install the new file in production directory
	$cmd = "$main::cfg{'CMD_CP'} -p $wrk_dir/$wrk_file $main::cfg{'BIND_DB_DIR'}/";

	$rs = sys_command_rs($cmd);
	return $rs if ($rs != 0);

	push_el(\@main::el, '_add_customer_master_dmn_als_db_data()', 'Ending...');

	0;

}

################################################################################
##
## Delete DNS record linked to customer domain alias in master db file
##
## @author  Laurent Declercq <laurent.declercq@ispcp.net>
## @since   1.0.7
## @fix     #2388
## @access  private
## @param   arrayref $data Ref. to an array that contains domain data
## @return  int 0 on success
sub _del_customer_master_dmn_als_db_data {

	push_el(\@main::el, '_del_customer_master_dmn_als_db_data()', 'Starting...');

	my ($data) = @_;

	if (!defined($data) || $data eq '') {
		push_el(
			\@main::el, '_del_customer_master_dmn_als_db_data()',
			'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my ($rs, $cmd);
	my $wrk_dir = "$main::cfg{'CONF_DIR'}/bind/working";
	my $bkp_dir = "$main::cfg{'CONF_DIR'}/bind/backup";
	my $wrk_file = "$main::cfg{'BASE_SERVER_VHOST'}.db";

	# Get the current working file
	my $master_db_file_content;

	($rs, $master_db_file_content) = get_file("$wrk_dir/$wrk_file");
	return $rs if($rs != 0);

	# Entry to be removed
	my $entry = "$main::cfg{'APACHE_SUEXEC_USER_PREF'}@${data[3]}\t\tIN\t\tA\t" .
		"$main::cfg{'BASE_SERVER_IP'}\n";

	# Remove entry
	$master_db_file_content =~ s/$entry//;

	# Backup current working file
	$cmd = "$main::cfg{'CMD_CP'} -p $wrk_dir/$wrk_file $bkp_dir/$wrk_file" . time;

	$rs = sys_command_rs($cmd);
	return $rs if ($rs != 0);

	# Store the new file in working dirctory
	$rs = store_file(
		"$wrk_dir/$wrk_file", $master_db_file_content, $main::cfg{'ROOT_USER'},
		$main::cfg{'ROOT_GROUP'}, 0644
	);
	return $rs if ($rs != 0);

	# Install the new file in production directory
	$cmd = "$main::cfg{'CMD_CP'} -p $wrk_dir/$wrk_file $main::cfg{'BIND_DB_DIR'}/";

	$rs = sys_command_rs($cmd);
	return $rs if ($rs != 0);

	push_el(\@main::el, '_del_customer_master_dmn_als_db_data()', 'Ending...');

	0;
}

################################################################################
##
## Backup all DNS configuration data for one domain
##
## @author  Laurent Declercq <laurent.declercq@ispcp.net>
## @since   1.0.7
## @param   arrayref $data Ref to an array that contains domain data
## @return  int 0 on success
##
sub _dmn_backup_named_data {

	push_el(\@main::el, 'dmn_backup_named_data()', 'Starting...');

	my ($data) = @_;

	if (!defined($data) || $data eq '') {
		push_el(
			\@main::el, 'dmn_backup_named_data()',
			'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my ($rs, $cmd);
	my $time = time;
	my $bkp_dir = "$main::cfg{'CONF_DIR'}/bind/backup";
	my $wrk_named_file = "$main::cfg{'CONF_DIR'}/bind/working/named.conf";
	my $zone_file = @$data[1] . '.db';
	my $wrk_zone_file = "$main::cfg{'CONF_DIR'}/bind/working/$zone_file";
	my $sys_zone_file = "$main::cfg{'BIND_DB_DIR'}/$zone_file";

	# Saving the current production main configuration file if it exist
	if(-e $main::cfg{'BIND_CONF_FILE'}) {
		$cmd = "$main::cfg{'CMD_CP'} -p $main::cfg{'BIND_CONF_FILE'} " .
			"$bkp_dir/named.conf.$time";

		$rs = sys_command_rs($cmd);
		return $rs if ($rs != 0);
	} elsif(-e $wrk_named_file) {
		$cmd =
			"$main::cfg{'CMD_CP'} -p $wrk_named_file $bkp_dir/named.conf.$time";

		$rs = sys_command_rs($cmd);
		return $rs if ($rs != 0);
	}

	# Saving the current production zone file if it exist - Begin
	if(-e $sys_zone_file) {
		$cmd =
			"$main::cfg{'CMD_CP'} -p $sys_zone_file $bkp_dir/$zone_file.$time";

		$rs = sys_command_rs($cmd);
		return $rs if ($rs != 0);
	} elsif (-e $wrk_zone_file) {
		$cmd =
			"$main::cfg{'CMD_CP'} -p $wrk_zone_file $bkp_dir/$zone_file.$time";

		$rs = sys_command_rs($cmd);
		return $rs if ($rs != 0);
	}

	push_el(\@main::el, 'dmn_backup_named_data()', 'Ending...');

	0;
}

################################################################################
##
## Adds all DNS configuration data for one domain
##
## @see     _dmn_add_named_cfg_data()
## @see     _dmn_add_named_db_data()
## @param   $data Ref to an array that contains domain data
## @return  int 0 on success
##
sub dmn_add_named_data {

	push_el(\@main::el, 'dmn_add_named_data()', 'Starting...');

	# Avoid useless works if the service is deactivated
	return 0 if ($main::cfg{'CMD_NAMED'} =~ /no/i);

	my ($data) = @_;

	if (!defined($data) || $data eq '') {
		push_el(
			\@main::el, 'dmn_add_named_data()', 'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my $rs;

	# Backup domain DNS configuration data if exists
	$rs = _dmn_backup_named_data($data);
	return $rs if ($rs != 0);

	# Add domain main DNS configuration entries
	$rs = _dmn_add_named_cfg_data($data);
	return $rs if ($rs != 0);

	# Create domain zone file
	$rs = _dmn_add_named_db_data($data);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'dmn_add_named_data()', 'Ending...');

	0;
}

################################################################################
##
## Changes all DNS configuration data for one domain
##
## @see     _dmn_add_named_data()
## @param   $data Ref to an array that contains domain data
## @return  int 0 on success
##
sub dmn_change_named_data {

	push_el(\@main::el, 'dmn_change_named_data()', 'Starting...');

	# Avoid useless works if the service is deactivated
	return 0 if ($main::cfg{'CMD_NAMED'} =~ /no/i);

	my ($data) = @_;

	if (!defined($data) || $data eq '') {
		push_el(
			\@main::el, 'dmn_change_named_data()',
			'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my $rs;

	# Change domain main DNS configuration entrie and zone file
	$rs = dmn_add_named_data($data);
	return $rs if ($rs != 0);

	# Fix for ticket #2388
	$rs = _add_customer_master_dmn_als_db_data($data);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'dmn_change_named_data()', 'Ending...');

	0;
}

################################################################################
##
## Deletes all DNS configuration data for one domain
##
## @see     _dmn_del_named_cfg_data() && _dmn_del_named_db_data()
## @param   $data Ref to an array that contains domain data
## @return  int 0 on success
##
sub dmn_del_named_data {

	push_el(\@main::el, 'dmn_del_named_data()', 'Starting...');

	# Avoid useless work if the service is deactivated
	return 0 if ($main::cfg{'CMD_NAMED'} =~ /no/i);

	my ($data) = @_;

	if (!defined($data) || $data eq '') {
		push_el(
			\@main::el, 'dmn_del_named_data()', 'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my $rs;

	# Backup domain DNS configuration data
	$rs = _dmn_backup_named_data($data);
	return $rs if ($rs != 0);

	# Remove domain main DNS configuration entries
	$rs = _dmn_del_named_cfg_data($data);
	return $rs if ($rs != 0);

	# Remove domain zone file
	$rs = _dmn_del_named_db_data($data);
	return $rs if ($rs != 0);

	# Fix for ticket #2388
	$rs = _del_customer_master_dmn_als_db_data($data);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'dmn_del_named_data()', 'Ending...');

	0;
}

################################################################################
##                             Httpd data managment                           ##
################################################################################

################################################################################
##
## Generate Auto Number
##
sub get_auto_num {

	push_el(\@main::el, 'get_auto_num()', 'Starting...');

	my ($rs, $num, $rdata) = (undef, undef, undef);

	my $sql = "
		INSERT INTO
			`auto_num` (msg)
		VALUE
			('auto-num')
		;
	";

	($rs, $rdata) = doSQL($sql);
	return $rs if ($rs != 0);

	$num = $main::db -> {'mysql_insertid'};

	push_el(\@main::el, 'get_auto_num()', 'Ending...');

	# FIXME (ispcomm): close will be never reached!
	return $num;

	close('db');
}

################################################################################
##
## Generate HTTPd Domain Group Entry
##
sub gen_httpd_dmn_group_entry {

	push_el(\@main::el, 'gen_httpd_dmn_group_entry()', 'Starting...');

	my ($dmn_data) = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'gen_httpd_dmn_group_entry()',
			'ERORR: Undefined input data...'
		);

		return (-1, '');
	}

	my ($rs, $rdata) = (undef, undef);
	my $dmn_id = @$dmn_data[0];
	my $dmn_name = @$dmn_data[1];
	my $dmn_grp = $dmn_name;
	my $dmn_ip = @$dmn_data[21];
	my $dmn_traffic_limit = @$dmn_data[10];
	my ($dmn_php, $dmn_cgi) = (@$dmn_data[19], @$dmn_data[20]);
	my $conf_dir = $main::cfg{'CONF_DIR'};
	my $tpl_dir = "$conf_dir/apache/parts";
	my $bw_disabled = '';

	if ($dmn_traffic_limit eq 0) {
		$bw_disabled = '#';
	}

	my (
		$dg_b, $dg_entry, $dg_e, $dmn_b, $dmn_entry, $dmn_e, $dmn_cgi_b,
		$dmn_cgi_entry, $dmn_cgi_e, $dmn_php_b, $dmn_php_entry, $dmn_php_e,
		$dmn_php2_b, $dmn_php2_entry, $dmn_php2_e, $dmn_awstats_b,
		$dmn_awstats_dynamic_entry, $dmn_awstats_static_entry, $dmn_awstats_e,
		$dmn_custom
	) = (
		'', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
		'', ''
	);

	(
		$rs, $dg_b, $dg_entry, $dg_e, $dmn_b, $dmn_entry, $dmn_e, $dmn_cgi_b,
		$dmn_cgi_entry, $dmn_cgi_e, $dmn_php_b, $dmn_php_entry, $dmn_php_e,
		$dmn_php2_b, $dmn_php2_entry, $dmn_php2_e, $dmn_awstats_b,
		$dmn_awstats_dynamic_entry, $dmn_awstats_static_entry, $dmn_awstats_e,
		$dmn_custom
	) = get_tpl (
		$tpl_dir, 'dg_b.tpl', 'dg_entry.tpl', 'dg_e.tpl', 'dmn_b.tpl',
		'dmn_entry.tpl', 'dmn_e.tpl', 'dmn_cgi_b.tpl', 'dmn_cgi_entry.tpl',
		'dmn_cgi_e.tpl', 'dmn_php_b.tpl', 'dmn_php_entry.tpl', 'dmn_php_e.tpl',
		'dmn_php2_b.tpl', 'dmn_php2_entry.tpl', 'dmn_php2_e.tpl',
		'dmn_awstats_b.tpl', 'dmn_awstats_dynamic_entry.tpl',
		'dmn_awstats_static_entry.tpl', 'dmn_awstats_e.tpl', 'custom.conf.tpl'
	);
	return ($rs, '') if ($rs != 0);

	my ($suexec_uid, $suexec_gid) = get_dmn_suexec_user($dmn_id);
	my $suexec_user_pref = $main::cfg{'APACHE_SUEXEC_USER_PREF'};
	my ($suexec_user, $suexec_group) = (
		"$suexec_user_pref$suexec_uid", "$suexec_user_pref$suexec_gid"
	);

	my %tag_hash = (
		'{DMN_GRP}' => $dmn_grp,
		'{DMN_NAME}' => $dmn_name,
		'{SELF}' => $dmn_name,
		'{DMN_IP}' => $dmn_ip,
		'{BASE_SERVER_VHOST}' => $main::cfg{'BASE_SERVER_VHOST'},
		'{BASE_SERVER_VHOST_PREFIX}'  => $main::cfg{'BASE_SERVER_VHOST_PREFIX'},
		'{WWW_DIR}'  => $main::cfg{'APACHE_WWW_DIR'},
		'{STARTER_DIR}' => $main::cfg{'PHP_STARTER_DIR'},
		'{PHP_VERSION}' => $main::cfg{'PHP_VERSION'},
		'{APACHE_LOG_DIR}' => $main::cfg{'APACHE_LOG_DIR'},
		'{GUI_ROOT_DIR}' => $main::cfg{'GUI_ROOT_DIR'},
		'{SCOREBOARDS_DIR}' => $main::cfg{'SCOREBOARDS_DIR'},
		'{PEAR_DIR}' => $main::cfg{'PEAR_DIR'},
		'{APACHE_USERS_LOG_DIR}' => $main::cfg{'APACHE_USERS_LOG_DIR'},
		'{CUSTOM_SITES_CONFIG_DIR}' => $main::cfg{'APACHE_CUSTOM_SITES_CONFIG_DIR'},
		'{MODS_DIR}'=> $main::cfg{'APACHE_MODS_DIR'},
		'{AWSTATS_WEB_DIR}' => $main::cfg{'AWSTATS_WEB_DIR'},
		'{AWSTATS_GROUP_AUTH}' => $main::cfg{'AWSTATS_GROUP_AUTH'},
		'{HTACCESS_USERS_FILE_NAME}' => $main::cfg{'HTACCESS_USERS_FILE_NAME'},
		'{HTACCESS_GROUPS_FILE_NAME}' => $main::cfg{'HTACCESS_GROUPS_FILE_NAME'},
		'{SUEXEC_USER}' => $suexec_user,
		'{SUEXEC_GROUP}' => $suexec_group,
		'{BWLIMIT}' => $dmn_traffic_limit,
		'{BWLIMIT_DISABLED}' => $bw_disabled,
		'##TEMPLATE' => ''
	);

	(
		$rs, $dg_b, $dg_entry, $dg_e, $dmn_b, $dmn_entry, $dmn_e, $dmn_cgi_b,
		$dmn_cgi_entry, $dmn_cgi_e, $dmn_php_b, $dmn_php_entry, $dmn_php_e,
		$dmn_php2_entry,  $dmn_awstats_dynamic_entry, $dmn_awstats_static_entry,
		$dmn_custom
	) = prep_tpl(
		\%tag_hash, $dg_b, $dg_entry, $dg_e, $dmn_b, $dmn_entry, $dmn_e,
		$dmn_cgi_b, $dmn_cgi_entry, $dmn_cgi_e, $dmn_php_b, $dmn_php_entry,
		$dmn_php_e, $dmn_php2_entry, $dmn_awstats_dynamic_entry,
		$dmn_awstats_static_entry, $dmn_custom
	);
	return ($rs, '') if ($rs != 0);

	# Add AWStats data

	my $awstats_entry = undef;

	if ($main::cfg{'AWSTATS_ACTIVE'} eq 'yes' &&
		$main::cfg{'AWSTATS_MODE'} eq 0) {
		# AWStats Dynamic
		$awstats_entry =
			"$dmn_awstats_b\n$dmn_awstats_dynamic_entry\n$dmn_awstats_e";
	} elsif ($main::cfg{'AWSTATS_ACTIVE'} eq 'yes' &&
		$main::cfg{'AWSTATS_MODE'} eq 1) {
		# AWStats Static
		$awstats_entry =
			"$dmn_awstats_b\n$dmn_awstats_static_entry\n$dmn_awstats_e";
	} else {
		# No AWStats
		$awstats_entry = "$dmn_awstats_b\n$dmn_awstats_e";
	}

	($rs, $dmn_entry) = repl_tag(
		$dmn_awstats_b, $dmn_awstats_e, $dmn_entry, $awstats_entry,
		'gen_httpd_dmn_group_entry'
	);
	return ($rs, '') if ($rs != 0);

	my $cgi_entry = undef;

	if ($dmn_cgi eq 'yes') {
		$cgi_entry = "$dmn_cgi_b$dmn_cgi_entry$dmn_cgi_e";
	} else {
		$cgi_entry = "$dmn_cgi_b$dmn_cgi_e";
	}

	($rs, $dmn_entry) = repl_tag(
		$dmn_cgi_b, $dmn_cgi_e, $dmn_entry, $cgi_entry,
		'gen_httpd_dmn_group_entry'
	);
	return ($rs, '') if ($rs != 0);

	my $php_entry = undef;

	if ($dmn_php eq 'no') {
		$php_entry = "$dmn_php_b$dmn_php_entry$dmn_php_e";
	} else {
		$php_entry = "$dmn_php_b$dmn_php_e";
		my $php2_entry = "$dmn_php2_b$dmn_php2_entry$dmn_php2_e";
		($rs, $dmn_entry) = repl_tag(
			$dmn_php2_b, $dmn_php2_e, $dmn_entry, $php2_entry,
			'gen_httpd_dmn_group_entry'
		);
		return ($rs, '') if ($rs != 0);
	}

	($rs, $dmn_entry) = repl_tag(
		$dmn_php_b, $dmn_php_e, $dmn_entry, $php_entry,
		'gen_httpd_dmn_group_entry'
	);
	return ($rs, '') if ($rs != 0);

	push_el(\@main::el, 'gen_httpd_dmn_group_entry()', "dmn_entry:\n$dmn_entry");

	my $dmn_group_entry = "$dmn_b$dmn_entry$dmn_e";
	($rs, $dg_entry) = repl_tag(
		$dmn_b, $dmn_e, $dg_entry, $dmn_group_entry, 'gen_httpd_dmn_group_entry'
	);

	# Create mod_cband scoreboard for domain group

	my $scoreboard_file = "$main::cfg{'SCOREBOARDS_DIR'}/$dmn_grp";

	$rs = sys_command_rs("$main::cfg{'CMD_TOUCH'} $scoreboard_file");
	return $rs if ($rs != 0);

	$rs = sys_command_rs("$main::cfg{'CMD_CHOWN'} " .
		"$main::cfg{'APACHE_USER'}:$main::cfg{'APACHE_GROUP'} $scoreboard_file");
	return $rs if ($rs != 0);

	# Custom domain config file
	if (!-e "$main::cfg{'APACHE_CUSTOM_SITES_CONFIG_DIR'}/$dmn_name.conf" ) {
		$rs = store_file(
			"$main::cfg{'APACHE_CUSTOM_SITES_CONFIG_DIR'}/$dmn_name.conf",
			$dmn_custom, $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'},
			0644
		);
		return $rs if ($rs != 0);
	}

	push_el(\@main::el, 'gen_httpd_dmn_group_entry()', "\n$dg_entry");

	return (0,  $dg_entry);
}

################################################################################
##
## Add HTTPd CFG Data
##
sub dmn_add_httpd_cfg_data {

	push_el(\@main::el, 'dmn_add_httpd_cfg_data()', 'Starting...');

	my ($dmn_data) = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_add_httpd_cfg_data()',
			'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my ($rs, $rdata);
	my $dmn_name = @$dmn_data[1];
	my $dmn_grp = $dmn_name;
	my $dmn_id = @$dmn_data[0];
	my $dmn_ip = @$dmn_data[21];
	my $conf_dir = $main::cfg{'CONF_DIR'};
	my $tpl_dir = "$conf_dir/apache/parts";
	my $working_dir = "$conf_dir/apache/working";
	my $backup_dir = "$conf_dir/apache/backup";
	my $sys_cfg = "$main::cfg{'APACHE_SITES_DIR'}/easyscp.conf";
	my $working_cfg = "$working_dir/easyscp.conf";

	if (!-e $working_cfg) {
		my $easyscp_base_tpl;

		($rs, $easyscp_base_tpl) = get_file($tpl_dir."/easyscp_base.tpl");
		return $rs if ($rs != 0);

		($rs, $rdata) = store_file(
			$working_cfg, $easyscp_base_tpl, 'root', 'root', 0600
		);
		return $rs if ($rs != 0);
	}

	my $backup_cfg = "$backup_dir/httpd.conf." . time();

	# Getting needed templates;

	my ($cfg_b, $cfg_e, $vh_b, $vh_entry, $vh_e, $dg_b, $dg_e ) = (
		'', '', '', '', '', '', ''
	);

	($rs, $cfg_b, $cfg_e, $vh_b, $vh_entry, $vh_e, $dg_b, $dg_e) = get_tpl (
		$tpl_dir, 'cfg_b.tpl', 'cfg_e.tpl', 'vh_b.tpl', 'vh_entry.tpl',
		'vh_e.tpl', 'dg_b.tpl', 'dg_e.tpl'
	);
	return $rs if ($rs != 0);

	# Create apache suexec user for this domain

	$rs = add_dmn_suexec_user($dmn_data);
	return $rs if ($rs != 0);

	# Preparing templates

	my ($vh_b_val, $vh_entry_val, $vh_e_val, $dg_b_val, $dg_e_val) = (
		'', '', '', '', ''
	);

	my %tag_hash = ('{IP}' => $dmn_ip);

	($rs, $vh_entry_val) = prep_tpl (\%tag_hash, $vh_entry);
	return $rs if ($rs != 0);

	%tag_hash = (
		'{IP}' => $dmn_ip,
		'{DMN_GRP}' => $dmn_grp
	);

	($rs, $vh_b_val, $vh_e_val, $dg_b_val, $dg_e_val) = prep_tpl (
		\%tag_hash, $vh_b, $vh_e, $dg_b, $dg_e
	);
	return $rs if ($rs != 0);

	# Let's get some configs;

	my ($sys, $working) = ('', '');

	($rs, $sys) = get_file($sys_cfg);
	return $rs if ($rs != 0);

	($rs, $working) = get_file($working_cfg);
	return $rs if ($rs != 0);

	# Check for $cfg_b, $cfg_e in working config;

	($rs, $rdata) = get_tag($cfg_b, $cfg_e, $working);
	return $rs if ($rs != 0);

	# Check for $vh_b_val, $vh_e_val in working config; Have we such Virtual
	# Host Entry in working config;

	($rs, $rdata) = get_tag($vh_b_val, $vh_e_val, $working);

	# No, we have not! We must add it here !
	if ($rs == -5) {
		my $repl = undef;

		$repl = "$vh_b_val$vh_entry_val$vh_e_val\n$vh_b$vh_e";

		($rs, $working) = repl_tag(
			$vh_b, $vh_e, $working, $repl, 'dmn_add_httpd_cfg_data'
		);
		return $rs if ($rs != 0);

		($rs, $rdata) = get_tag($vh_b_val, $vh_e_val, $working);
		return $rs if ($rs != 0);

		push_el(\@main::el, 'dmn_add_httpd_cfg_data()', "working:\n$working");
	} elsif ($rs != 0) {
		return $rs;
	}

	# Let's edit Virtual Host Entry

	my $vh_entry_contents = $rdata;

	# Check for valued Domain Group Entry in this Virtual Host Entry;

	($rs, $rdata) = get_tag( $dg_b_val, $dg_e_val, $vh_entry_contents);

	if ($rs == 0) {
		# We have one ! We must delete it because of possible
		# future changes in this Domain Group Entry;
		($rs, $vh_entry_contents) = del_tag(
			$dg_b_val, "$dg_e_val\n", $vh_entry_contents
		);
		return $rs if ($rs != 0);
	}

	# Check for extension ($dg_b, $dg_e) Domain Group Entry in this
	# Virtual Host Entry

	($rs, $rdata) = get_tag($dg_b, $dg_e, $vh_entry_contents);
	return $rs if ($rs != 0);

	# Let's construct Domain Group Entry and Domain Group
	# valued (with extension tags) Entry

	my ($dg_entry, $dg_entry_val) = ('', '');

	($rs, $dg_entry) = gen_httpd_dmn_group_entry($dmn_data);
	return $rs if ($rs != 0);

	$dg_entry_val = "$dg_b$dg_e$dg_b_val$dg_entry$dg_e_val\n";

	# Constructing NEW Virtual Host Entry

	($rs, $vh_entry_contents) = repl_tag(
		$dg_b, $dg_e, $vh_entry_contents, $dg_entry_val, 'dmn_add_httpd_cfg_data'
	);
	return $rs if ($rs != 0);

	# Putting NEW Virtual Host Entry in working config

	($rs, $working) = repl_tag(
		$vh_b_val, $vh_e_val, $working, $vh_entry_contents,
		'dmn_add_httpd_cfg_data'
	);
	return $rs if ($rs != 0);

	# Check for $cfg_b, $cfg_e data in system config

	($rs, $rdata) = get_tag($cfg_b, $cfg_e, $sys);

	if ($rs == 0) { # Yes, We have some ! We'll replace it;
		($rs, $sys) = repl_tag(
			$cfg_b, $cfg_e, $sys, $working, 'dmn_add_httpd_cfg_data'
		);
		return $rs if ($rs != 0);

	} elsif ($rs == -5) { # No, We haven't ! We'll add it;
		$sys .= $working;
	} else { # Some error that should not be happend ! Exiting...
		return $rs;
	}

	# Backuping system config

	($rs, $rdata) = sys_command("$main::cfg{'CMD_CP'} -p $sys_cfg $backup_cfg");
	return $rs if ($rs != 0);

	# Let's store all the stuff;

	($rs, $rdata) = store_file(
		$working_cfg, $working, $main::cfg{'ROOT_USER'},
		$main::cfg{'ROOT_GROUP'}, 0644
	);
	return $rs if ($rs != 0);

	($rs, $rdata) = store_file($sys_cfg,
		$sys, $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'}, 0644
	);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'dmn_add_httpd_cfg_data()', 'Ending...');

	0;
}

################################################################################
##
## Change HTTPd CFG Data
##
sub dmn_change_httpd_cfg_data {

	push_el(\@main::el, 'dmn_change_httpd_cfg_data()', 'Starting...');

	my ($dmn_data) = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_change_httpd_cfg_data()',
			'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my $rs = dmn_add_httpd_cfg_data($dmn_data);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'dmn_change_httpd_cfg_data()', 'Ending...');

	0;
}

################################################################################
##
## Delete HTTPd CFG Data
##
sub dmn_del_httpd_cfg_data {

	push_el(\@main::el, 'dmn_del_httpd_cfg_data()', 'Starting...');

	my ($dmn_data)   = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_del_httpd_cfg_data()',
			'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my ($rs, $rdata);
	my $dmn_name = @$dmn_data[1];
	my $dmn_grp = $dmn_name;
	my $dmn_ip = @$dmn_data[21];
	my $conf_dir = $main::cfg{'CONF_DIR'};
	my $tpl_dir = "$conf_dir/apache/parts";
	my $working_dir = "$conf_dir/apache/working";
	my $backup_dir = "$conf_dir/apache/backup";
	my $sys_cfg = "$main::cfg{'APACHE_SITES_DIR'}/easyscp.conf";
	my $working_cfg = "$working_dir/easyscp.conf";
	my $backup_cfg = "$backup_dir/httpd.conf." . time();

	# Getting needed templates

	my ($cfg_b, $cfg_e, $vh_b, $vh_entry, $vh_e, $dg_b, $dg_e) = (
		'', '', '', '', '', '', ''
	);

	($rs, $cfg_b, $cfg_e, $vh_b, $vh_entry, $vh_e, $dg_b, $dg_e ) = get_tpl (
		$tpl_dir, 'cfg_b.tpl', 'cfg_e.tpl', 'vh_b.tpl', 'vh_entry.tpl',
		'vh_e.tpl', 'dg_b.tpl', 'dg_e.tpl'
	);
	return $rs if ($rs != 0);

	# Delete apache suexec user for this domain

	$rs = del_dmn_suexec_user($dmn_data);
	return $rs if ($rs != 0);

	# Preparing templates;

	my ($vh_b_val, $vh_entry_val, $vh_e_val, $dg_b_val, $dg_e_val) = (
		'', '', '', '', ''
	);

	my %tag_hash = ('{IP}' => $dmn_ip);

	($rs, $vh_entry_val) = prep_tpl (\%tag_hash, $vh_entry);
	return $rs if ($rs != 0);

	%tag_hash = (
		'{IP}' => $dmn_ip,
		'{DMN_GRP}' => $dmn_grp
	);

	($rs, $vh_b_val, $vh_e_val, $dg_b_val, $dg_e_val) = prep_tpl (
		\%tag_hash, $vh_b, $vh_e, $dg_b, $dg_e
	);
	return $rs if ($rs != 0);

	# Let's get some configs;

	my ($sys, $working) = ('', '');

	($rs, $sys) = get_file($sys_cfg);
	return $rs if ($rs != 0);

	($rs, $working) = get_file($working_cfg);
	return $rs if ($rs != 0);

	# Check for $cfg_b, $cfg_e in working config

	($rs, $rdata) = get_tag($cfg_b, $cfg_e, $working);
	return $rs if ($rs != 0);

	# Check for $vh_b_val, $vh_e_val in working config; Have we such Virtual
	# Host Entry in working config

	($rs, $rdata) = get_tag($vh_b_val, $vh_e_val, $working);

	if ($rs == -5) { # No, we have not! We must add it here !
		my $repl = undef;
		$repl = "$vh_b_val$vh_entry_val$vh_e_val\n$vh_b$vh_e";

		($rs, $working) = repl_tag(
			$vh_b, $vh_e, $working, $repl, 'dmn_del_httpd_cfg_data'
		);
		return $rs if ($rs != 0);

		($rs, $rdata) = get_tag($vh_b_val, $vh_e_val, $working);
		return $rs if ($rs != 0);

	} elsif ($rs != 0) {
		return $rs;
	}

	# Let's edit Virtual Host Entry;

	my $vh_entry_contents = $rdata;

	# Check for valued Domain Group Entry in this Virtual Host Entry;

	($rs, $rdata) = get_tag( $dg_b_val, $dg_e_val, $vh_entry_contents);

	if ($rs == 0) {
		# We have one ! We must delete it because of possible future
		# changes in this Domain Group Entry;
		($rs, $vh_entry_contents) = del_tag(
			$dg_b_val, "$dg_e_val\n", $vh_entry_contents
		);
		return $rs if ($rs != 0);
	}

	# Check for extension ($dg_b, $dg_e) Domain Group Entry in this Virtual
	# Host Entry

	($rs, $rdata) = get_tag($dg_b, $dg_b, $vh_entry_contents);
	return $rs if ($rs != 0);


	# Putting NEW Virtual Host Entry in working config

	($rs, $working) = repl_tag(
		$vh_b_val, $vh_e_val, $working, $vh_entry_contents,
		'dmn_del_httpd_cfg_data'
	);
	return $rs if ($rs != 0);


	# Check for $cfg_b, $cfg_e data in system config

	($rs, $rdata) = get_tag($cfg_b, $cfg_e, $sys);
	if ($rs == 0) { # Yes, We have some ! We'll replace it;
		($rs, $sys) = repl_tag(
			$cfg_b, $cfg_e, $sys, $working, 'dmn_del_httpd_cfg_data'
		);
		return $rs if ($rs != 0);
	} elsif ($rs == -5) { # No, We haven't ! We'll add it;
		$sys .= $working;
	} else { # Some error that should not be happend ! Exiting...
		return $rs;
	}

	# Backuping system config

	($rs, $rdata) = sys_command("$main::cfg{'CMD_CP'} -p $sys_cfg $backup_cfg");
	return $rs if ($rs != 0);

	# Let's store all the stuff;

	($rs, $rdata) = store_file(
		$working_cfg, $working, $main::cfg{'ROOT_USER'},
		$main::cfg{'ROOT_GROUP'}, 0644
	);
	return $rs if ($rs != 0);

	($rs, $rdata) = store_file(
		$sys_cfg, $sys, $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'}, 0644
	);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'dmn_del_httpd_cfg_data()', 'Ending...');

	0;
}

################################################################################
##
## Add HTTPd File Data
##
sub dmn_add_httpd_file_data {

	push_el(\@main::el, 'dmn_add_httpd_file_data()', 'Starting...');

	my ($dmn_data) = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_add_httpd_file_data()',
			'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my ($rs, $rdata, $cfg);
	my $dmn_id = @$dmn_data[0];
	my $dmn_name = @$dmn_data[1];
	my $root_dir = $main::cfg{'ROOT_DIR'};
	my $www_dir = $main::cfg{'APACHE_WWW_DIR'};
	my $pear_dir = $main::cfg{'PEAR_DIR'};
	my $starter_dir = $main::cfg{'PHP_STARTER_DIR'};
	my $timezone = $main::cfg{'PHP_TIMEZONE'};
	my $conf_dir = $main::cfg{'CONF_DIR'};
	my $httpd_uid = $main::cfg{'APACHE_USER'};
	my $httpd_gid = $main::cfg{'APACHE_GROUP'};
	my ($sys_uid, $sys_gid) = get_dmn_suexec_user($dmn_id);
	my $suexec_user_pref = $main::cfg{'APACHE_SUEXEC_USER_PREF'};
	my $sysUser = "$suexec_user_pref$sys_uid";
	my $sysGroup = "$suexec_user_pref$sys_gid";

	# Starter directory for usual user

	if(!(-d "$starter_dir/$dmn_name")) {
		$rs = makepath("$starter_dir/$dmn_name", $sysUser, $sysGroup, 0555);
		return $rs if ($rs != 0);
	}

	if (! -d "$starter_dir/$dmn_name/php5") {
		$rs = makepath(
			"$starter_dir/$dmn_name/php5", $sysUser, $sysGroup, 0550
		);
		return $rs if ($rs != 0);
	}

	# AWStats Directory (if static AWStats is enabled)

	if ($main::cfg{'AWSTATS_ACTIVE'} eq 'yes' &&
		$main::cfg{'AWSTATS_MODE'} eq 1) {

		if (! -d "$www_dir/$dmn_name/statistics") {
			$rs = makepath(
				"$www_dir/$dmn_name/statistics", $sysUser, $sysGroup, 0755
			);
			return $rs if ($rs != 0);
		}
	}

	# Domain WWW directories

	$rs = makepath("$www_dir/$dmn_name", $sysUser, $httpd_gid, 0770);
	return $rs if ($rs != 0);

	$rs = makepath("$www_dir/$dmn_name/cgi-bin", $sysUser, $sysGroup, 0755);
	return $rs if ($rs != 0);

	$rs = makepath("$www_dir/$dmn_name/logs",$sysUser, $httpd_gid, 0770);
	return $rs if ($rs != 0);

	$rs = makepath("$www_dir/$dmn_name/phptmp", $sysUser, $httpd_gid, 0770);
	return $rs if ($rs != 0);

	$rs = makepath("$www_dir/$dmn_name/backups", $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'}, 0755);
	return $rs if ($rs != 0);

	$rs = makepath("$www_dir/$dmn_name/errors", $sysUser, $sysGroup, 0775);
	return $rs if ($rs != 0);

	$rs = makepath("$www_dir/$dmn_name/errors/inc", $sysUser, $sysGroup, 0775);
	return $rs if ($rs != 0);


	# Domain WWW files

	($rs, $rdata) = store_file(
		"$www_dir/$dmn_name/.htpasswd", "\n", $sysUser, $httpd_gid, 0640
	);
	return $rs if ($rs != 0);

	($rs, $rdata) = store_file(
		"$www_dir/$dmn_name/.htgroup", "\n", $sysUser, $httpd_gid, 0640
	);
	return $rs if ($rs != 0);

	# Default error pages

	my @errordocs = (401, 403, 404, 500, 503);
	my ($i, $key) = ('', '');

	for($i = 0; $i < scalar(@errordocs); $i++) {
		$key = $errordocs[$i];

		if (-e "$root_dir/gui/errordocs/$key.html") {
			$rs = sys_command(
				"$main::cfg{'CMD_ECHO'} n | $main::cfg{'CMD_CP'} -ip " .
				"$root_dir/gui/errordocs/$key.html $www_dir/$dmn_name/errors/ ".
				"2>/dev/null"
			);
			return $rs if ($rs != 0);

			$rs = setfmode(
				"$www_dir/$dmn_name/errors/$key.html", $sysUser, $sysGroup,
				0644
			);
			return $rs if ($rs != 0);
		}
	}

	opendir(DIR, "$root_dir/gui/errordocs/inc/");
	my @files = readdir(DIR);
	closedir(DIR);

	foreach (@files) {
		next if ($_ eq '.' || $_ eq '..');
		sys_command(
			"$main::cfg{'CMD_ECHO'} n | $main::cfg{'CMD_CP'} -ip " .
				"$root_dir/gui/errordocs/inc/$_ $www_dir/$dmn_name/errors/inc/ ".
					"2>/dev/null"
		);
		return $rs if ($rs != 0);

		$rs = setfmode(
			"$www_dir/$dmn_name/errors/inc/$_", $sysUser, $sysGroup, 0644
		);
		return $rs if ($rs != 0);
	}

	# Default domain page template

	# check if htdocs folder does not exist
	if (!(-e "$www_dir/$dmn_name/htdocs/")) {
		$rs = makepath(
			"$www_dir/$dmn_name/htdocs", $sysUser, $sysGroup, 0775
		);
		return $rs if ($rs != 0);

		my ($index_tpl, $err_cfg_dir) = (undef, undef);
		my $vhost = $main::cfg{'BASE_SERVER_VHOST'};
		my $prefix = $main::cfg{'BASE_SERVER_VHOST_PREFIX'};
		$err_cfg_dir = "$main::cfg{'GUI_ROOT_DIR'}/domain_default_page";

		($rs, $index_tpl) = get_tpl($err_cfg_dir, 'index.html');
		return $rs if ($rs != 0);

		my $decoded_dmn_name = idn_to_unicode($dmn_name, 'utf-8');

		my %tag_hash = (
			'{DOMAIN_NAME}' => $decoded_dmn_name,
			'{THEME_CHARSET}' => 'UTF-8',
			'{BASE_SERVER_VHOST}' => $vhost,
			'{BASE_SERVER_VHOST_PREFIX}' => $prefix
		);

		($rs, $cfg) = prep_tpl(\%tag_hash, $index_tpl);
		return $rs if ($rs != 0);

		($rs, $rdata) = store_file(
			"$www_dir/$dmn_name/htdocs/index.html", $cfg, $sysUser, $sysGroup,
			0644
		);
		return $rs if ($rs != 0);

		$rs = sys_command(
			"$main::cfg{'CMD_CP'} -p " .
			"$root_dir/gui/domain_default_page/easyscp.css $www_dir/$dmn_name/htdocs/easyscp.css"
		);
		return $rs if ($rs != 0);

		$rs = setfmode(
			"$www_dir/$dmn_name/htdocs/easyscp.css", $sysUser, $sysGroup, 0644
		);
		return $rs if ($rs != 0);

		$rs = sys_command(
			"$main::cfg{'CMD_CP'} -Rp " .
			"$root_dir/gui/domain_default_page/images $www_dir/$dmn_name/htdocs/"
		);
		return $rs if ($rs != 0);

		$rs = setfmode(
			"$www_dir/$dmn_name/htdocs/images", $sysUser, $sysGroup, 0755
		);
		return $rs if ($rs != 0);

		opendir(DIR, "$www_dir/$dmn_name/htdocs/images/");
		my @files = readdir(DIR);
		closedir(DIR);

		foreach (@files) {
            next if ($_ eq '.' || $_ eq '..');

			$rs = setfmode(
				"$www_dir/$dmn_name/htdocs/images/$_",
				$sysUser,
				$sysGroup,
				0644
			);
			return $rs if ($rs != 0);
		}
	}

    # Default disable page template;

	# check if disable folder does not exist
	if (!(-e "$www_dir/$dmn_name/disabled")) {
		$rs = makepath(
			"$www_dir/$dmn_name/disabled", $httpd_uid, $httpd_gid, 0755
		);
		return $rs if ($rs != 0);

		my ($index_tpl, $err_cfg_dir) = (undef, undef);
		my $vhost = $main::cfg{'BASE_SERVER_VHOST'};
		$err_cfg_dir = "$main::cfg{'GUI_ROOT_DIR'}/domain_disable_page";

		($rs, $index_tpl) = get_tpl($err_cfg_dir, 'index.html');
		return $rs if ($rs != 0);

		my $decoded_dmn_name = idn_to_unicode($dmn_name, 'utf-8');

		my %tag_hash = (
			'{DOMAIN_NAME}' => $decoded_dmn_name,
			'{THEME_CHARSET}' => 'UTF-8'
		);

		($rs, $cfg) = prep_tpl(\%tag_hash, $index_tpl);
		return $rs if ($rs != 0);

		($rs, $rdata) = store_file(
			"$www_dir/$dmn_name/disabled/index.html",
			$cfg, $httpd_uid, $httpd_gid, 0644
		);
		return $rs if ($rs != 0);

		$rs = sys_command(
			"$main::cfg{'CMD_CP'} -p " .
			"$root_dir/gui/domain_disable_page/easyscp.css $www_dir/$dmn_name/disabled/easyscp.css"
		);
		return $rs if ($rs != 0);

		$rs = setfmode(
			"$www_dir/$dmn_name/disabled/easyscp.css", $httpd_uid, $httpd_gid, 0644
		);
		return $rs if ($rs != 0);

		$rs = sys_command(
			"$main::cfg{'CMD_CP'} -Rp " .
			"$root_dir/gui/domain_disable_page/images $www_dir/$dmn_name/disabled/"
		);
		return $rs if ($rs != 0);

		$rs = setfmode(
			"$www_dir/$dmn_name/disabled/images", $httpd_uid, $httpd_gid, 0755
		);
		return $rs if ($rs != 0);

		opendir(DIR, "$www_dir/$dmn_name/disabled/images/");
		my @files = readdir(DIR);
		closedir(DIR);

		foreach (@files) {
            next if ($_ eq "." || $_ eq "..");

			$rs = setfmode(
				"$www_dir/$dmn_name/disabled/images/$_", $httpd_uid, $httpd_gid,
				0644
			);
			return $rs if ($rs != 0);
		}
	}

	if (!(-e "$starter_dir/$dmn_name/php5/browscap.ini")) {
		my $ini_tpl = undef;
		my $ini_cfg_dir = "$main::cfg{'CONF_DIR'}/fcgi/parts/master/php5";

		($rs, $ini_tpl) = get_tpl($ini_cfg_dir, 'browscap.ini');
		return $rs if ($rs != 0);

		($rs, $rdata) = store_file(
			"$starter_dir/$dmn_name/php5/browscap.ini", $ini_tpl, $sysUser, $sysGroup,
			0440
		);
		return $rs if ($rs != 0);
	}

	if (!(-e "$starter_dir/$dmn_name/php5/php.ini")) {
		my $ini_tpl = undef;
		my $ini_cfg_dir = "$main::cfg{'CONF_DIR'}/fcgi/parts/php5";

		($rs, $ini_tpl) = get_tpl($ini_cfg_dir, 'php.ini');
		return $rs if ($rs != 0);

		my %tag_hash = (
			'{PEAR_DIR}' => $pear_dir,
			'{WWW_DIR}'  => $www_dir,
			'{PHP_STARTER_DIR}' => $starter_dir,
			'{DMN_NAME}' => $dmn_name,
			'{PHP_TIMEZONE}' => $timezone
		);

		($rs, $cfg) = prep_tpl(\%tag_hash, $ini_tpl);
		return $rs if ($rs != 0);

		($rs, $rdata) = store_file(
			"$starter_dir/$dmn_name/php5/php.ini", $cfg, $sysUser, $sysGroup,
			0440
		);
		return $rs if ($rs != 0);
	}

	# php-fcgi-starters for every domain

	if (!(-e "$starter_dir/$dmn_name/php5-fcgi-starter")) {
		my $starter_tpl = undef;
		my $cfg_dir = "$main::cfg{'CONF_DIR'}/fcgi/parts";

		($rs, $starter_tpl) = get_tpl($cfg_dir, 'php5-fcgi-starter.tpl');
		return $rs if ($rs != 0);

		my %tag_hash = (
			'{WWW_DIR}' => $www_dir,
			'{PHP_STARTER_DIR}'	=> $starter_dir,
			'{PHP5_FASTCGI_BIN}' => $main::cfg{'PHP5_FASTCGI_BIN'},
			'{DMN_NAME}' => $dmn_name
		);

		($rs, $cfg) = prep_tpl(\%tag_hash, $starter_tpl);
		return $rs if ($rs != 0);

		($rs, $rdata) = store_file(
			"$starter_dir/$dmn_name/php5-fcgi-starter", $cfg, $sysUser,
			$sysGroup, 0550
		);
		return $rs if ($rs != 0);
	}

	push_el(\@main::el, 'dmn_add_httpd_file_data()', 'Ending...');

	0;
}

################################################################################
##
## Change HTTPd File Data
##
sub dmn_change_httpd_file_data {

	push_el(\@main::el, 'dmn_change_httpd_file_data()', 'Starting...');

	my ($dmn_data) = @_;
	my ($rs, $rdata, $cfg) = (undef, undef, undef);

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_change_httpd_file_data()',
			'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my $dmn_id = @$dmn_data[0];
	my $dmn_name = @$dmn_data[1];
	my $root_dir = $main::cfg{'ROOT_DIR'};
	my $www_dir = $main::cfg{'APACHE_WWW_DIR'};
	my $pear_dir = $main::cfg{'PEAR_DIR'};
	my $starter_dir = $main::cfg{'PHP_STARTER_DIR'};
	my $timezone = $main::cfg{'PHP_TIMEZONE'};
	my $conf_dir = $main::cfg{'CONF_DIR'};
	my $httpd_uid = $main::cfg{'APACHE_USER'};
	my $httpd_gid = $main::cfg{'APACHE_GROUP'};
	my ($sys_uid, $sys_gid) = get_dmn_suexec_user($dmn_id);
	my $suexec_user_pref = $main::cfg{'APACHE_SUEXEC_USER_PREF'};
	my $sysUser = "$suexec_user_pref$sys_uid";
	my $sysGroup = "$suexec_user_pref$sys_gid";

	# Starter-Scripts for FastCGI

	if(! -d "$starter_dir/$dmn_name") {
		$rs = makepath("$starter_dir/$dmn_name", $sysUser, $sysGroup, 0755);
		return $rs if ($rs != 0);
	}

	if (! -d "$starter_dir/$dmn_name/php5") {
		$rs = makepath(
			"$starter_dir/$dmn_name/php5", $sysUser, $sysGroup, 0550
		);
		return $rs if ($rs != 0);
	}

	# AWStats Directory (if static AWStats is enabled)

	if ($main::cfg{'AWSTATS_ACTIVE'} eq 'yes'
		&& $main::cfg{'AWSTATS_MODE'} eq 1) {

		if (! -d "$www_dir/$dmn_name/statistics") {
			$rs = makepath(
				"$www_dir/$dmn_name/statistics", $sysUser, $sysGroup, 0555
			);
			return $rs if ($rs != 0);
		}
	}

	# Domain WWW directories

	if(! -d "$www_dir/$dmn_name/phptmp") {
		$rs = makepath("$www_dir/$dmn_name/phptmp", $sysUser, $sysGroup, 0770);
		return $rs if ($rs != 0);
	}

	if(! -d "$www_dir/$dmn_name/backups") {
		$rs = makepath("$www_dir/$dmn_name/backups", $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'}, 0755);
		return $rs if ($rs != 0);
	}

	# Default error pages

	if(! -d "$www_dir/$dmn_name/errors") {
		$rs = makepath("$www_dir/$dmn_name/errors", $sysUser, $sysGroup, 0775);
		return $rs if ($rs != 0);
	}

	if(! -d "$www_dir/$dmn_name/errors/inc") {
		$rs = makepath(
			"$www_dir/$dmn_name/errors/inc", $sysUser, $sysGroup, 0775
		);
		return $rs if ($rs != 0);
	}

	my @errordocs = (401, 403, 404, 500, 503);
	my ($i, $key) = ('', '');

	for($i = 0; $i < scalar(@errordocs); $i++) {
		$key = $errordocs[$i];

		if (-e "$root_dir/gui/errordocs/$key.html") {
			$rs = sys_command(
				"$main::cfg{'CMD_ECHO'} n | $main::cfg{'CMD_CP'} -ip " .
				"$root_dir/gui/errordocs/$key.html $www_dir/$dmn_name/errors/ " .
				"2>/dev/null"
			);
			return $rs if ($rs != 0);

			$rs = setfmode(
				"$www_dir/$dmn_name/errors/$key.html", $sysUser, $sysGroup,
				0644
			);
			return $rs if ($rs != 0);
		}
	}

	opendir(DIR, "$root_dir/gui/errordocs/inc/");
	my @files = readdir(DIR);
	closedir(DIR);

	foreach (@files) {
		next if ($_ eq '.' || $_ eq '..');
		sys_command(
			"$main::cfg{'CMD_ECHO'} n | $main::cfg{'CMD_CP'} -ip ".
			"$root_dir/gui/errordocs/inc/$_ $www_dir/$dmn_name/errors/inc/ ".
			"2>/dev/null"
		);
		return $rs if ($rs != 0);

		$rs = setfmode(
			"$www_dir/$dmn_name/errors/inc/$_", $sysUser, $sysGroup, 0644
		);
		return $rs if ($rs != 0);
	}

    # Default disable page template;

	# check if disable folder does not exist and the domain is not disabled
	if (!-e "$www_dir/$dmn_name/disabled" &&
		!-e "$www_dir/$dmn_name/htdocs.disabled") {

		$rs = makepath(
			"$www_dir/$dmn_name/disabled", $httpd_uid, $httpd_gid, 0755
		);
		return $rs if ($rs != 0);

		my ($index_tpl, $err_cfg_dir) = (undef, undef);
		my $vhost = $main::cfg{'BASE_SERVER_VHOST'};
		$err_cfg_dir = "$main::cfg{'GUI_ROOT_DIR'}/domain_disable_page";

		($rs, $index_tpl) = get_tpl($err_cfg_dir, 'index.html');
		return $rs if ($rs != 0);

		my $decoded_dmn_name = idn_to_unicode($dmn_name, 'utf-8');

		my %tag_hash = (
			'{DOMAIN_NAME}' => $decoded_dmn_name,
			'{BASE_SERVER_VHOST}' => $vhost
		);

		($rs, $cfg) = prep_tpl(\%tag_hash, $index_tpl);
		return $rs if ($rs != 0);

		($rs, $rdata) = store_file(
			"$www_dir/$dmn_name/disabled/index.html", $cfg, $httpd_uid,
			$httpd_gid,  0644
		);
		return $rs if ($rs != 0);

		$rs = sys_command(
			"$main::cfg{'CMD_CP'} -p " .
			"$root_dir/gui/domain_disable_page/easyscp.css $www_dir/$dmn_name/disabled/easyscp.css"
		);
		return $rs if ($rs != 0);

		$rs = setfmode(
			"$www_dir/$dmn_name/disabled/easyscp.css", $httpd_uid, $httpd_gid, 0644
		);
		return $rs if ($rs != 0);

		$rs = sys_command(
			"$main::cfg{'CMD_CP'} -Rp " .
			"$root_dir/gui/domain_disable_page/images $www_dir/$dmn_name/disabled/"
		);
		return $rs if ($rs != 0);

		$rs = setfmode(
			"$www_dir/$dmn_name/disabled/images", $httpd_uid, $httpd_gid, 0755
		);
		return $rs if ($rs != 0);

		opendir(DIR, "$www_dir/$dmn_name/disabled/images/");
		my @files = readdir(DIR);
		closedir(DIR);

		foreach (@files) {
			# ignore . and .. :
            next if ($_ eq "." || $_ eq "..");

			$rs = setfmode(
				"$www_dir/$dmn_name/disabled/images/$_", $httpd_uid, $httpd_gid,
				0644
			);
			return $rs if ($rs != 0);
		}
	}

	# Workaround to recover the initial status of the domain
	# and restore it after changes.
	# See #2262 for more information about this issue.
	if(-e "$www_dir/$dmn_name/htdocs.disabled") {
		$main::after_change_status = 'disabled';
	}

	# php.ini for the domain
	########################

	# backup current file if one exist
	if (-e "$starter_dir/$dmn_name/php5/php.ini") {
		$rs = sys_command_rs(
			"$main::cfg{'CMD_CP'} -p $starter_dir/$dmn_name/php5/php.ini " .
			"$conf_dir/fcgi/backup/${dmn_name}.php.ini." . time
		);
		return $rs if ($rs != 0);

	}

	($rs, my $ini_tpl) = get_file("$conf_dir/fcgi/parts/php5/php.ini");
	return $rs if ($rs != 0);

	($rs, $cfg) = prep_tpl(
		{
			'{PEAR_DIR}' => $pear_dir,
			'{WWW_DIR}'  => $www_dir,
			'{DMN_NAME}' => $dmn_name,
			'{PHP_TIMEZONE}' => $timezone
		},
			$ini_tpl
	);
	return $rs if ($rs != 0);

	($rs, $rdata) = store_file(
		"$starter_dir/$dmn_name/php5/php.ini", $cfg, $sysUser, $sysGroup,
		0440
	);
	return $rs if ($rs != 0);

	# php5-fcgi-starter for the domain
	##################################
	if (! -e "$starter_dir/$dmn_name/php5-fcgi-starter") {
		my $starter_tpl = undef;
		my $cfg_dir = "$main::cfg{'CONF_DIR'}/fcgi/parts";

		($rs, $starter_tpl) = get_tpl($cfg_dir, 'php5-fcgi-starter.tpl');
		return $rs if ($rs != 0);

		my %tag_hash = (
			'{PHP_STARTER_DIR}' => $starter_dir,
			'{WWW_DIR}' => $www_dir,
			'{PHP5_FASTCGI_BIN}' => $main::cfg{'PHP5_FASTCGI_BIN'},
			'{DMN_NAME}' => $dmn_name
		);

		($rs, $cfg) = prep_tpl(\%tag_hash, $starter_tpl);
		return $rs if ($rs != 0);

		($rs, $rdata) = store_file(
			"$starter_dir/$dmn_name/php5-fcgi-starter", $cfg, $sysUser,
			$sysGroup, 0550
		);
		return $rs if ($rs != 0);
	}

	push_el(\@main::el, 'dmn_change_httpd_file_data()', 'Ending...');

	0;
}

################################################################################
##
## Delete HTTPd File Data
##
sub dmn_del_httpd_file_data {

	push_el(\@main::el, 'dmn_del_httpd_file_data()', 'Starting...');

	my ($dmn_data)   = @_;
	my ($rs, $rdata) = (undef, undef);

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_del_httpd_file_data()',
			'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my $dmn_name = @$dmn_data[1];
	my $root_dir = $main::cfg{'ROOT_DIR'};
	my $www_dir = $main::cfg{'APACHE_WWW_DIR'};
	my $starter_dir = $main::cfg{'PHP_STARTER_DIR'};

	# Starter directory

	if (-e "$starter_dir/$dmn_name") {
		$rs = del_dir("$starter_dir/$dmn_name");
	}

	# Domain WWW directories;

	if (-e "$www_dir/$dmn_name") {
		$rs = del_dir("$www_dir/$dmn_name");
	} elsif ( -e "$www_dir/$dmn_name.disabled" ) {
		$rs = del_dir("$www_dir/$dmn_name.disabled");
	}
	return $rs if ($rs != 0);


	# Remove mod_cband scoreboard

	if (-e "$main::cfg{'SCOREBOARDS_DIR'}/$dmn_name") {
		$rs = del_file("$main::cfg{'SCOREBOARDS_DIR'}/$dmn_name");
		return $rs if ($rs != 0);
	}

	# Custom http config

	if (-e "$main::cfg{'APACHE_CUSTOM_SITES_CONFIG_DIR'}/$dmn_name.conf"){
		$rs = del_file(
			"$main::cfg{'APACHE_CUSTOM_SITES_CONFIG_DIR'}/$dmn_name.conf"
		);
		return $rs if ($rs != 0);
	}

	if (-e "$main::cfg{'APACHE_USERS_LOG_DIR'}/$dmn_name-error.log") {
		($rs, $rdata) = del_file(
			"$main::cfg{'APACHE_USERS_LOG_DIR'}/$dmn_name-error.log"
		);
		return $rs if ($rs != 0);
	}

	if (-e "$main::cfg{'APACHE_USERS_LOG_DIR'}/$dmn_name-access.log") {
		($rs, $rdata) = del_file(
			"$main::cfg{'APACHE_USERS_LOG_DIR'}/$dmn_name-access.log"
		);
		return $rs if ($rs != 0);
	}

	if (-e "$main::cfg{'APACHE_LOG_DIR'}/$dmn_name-combined.log") {
		($rs, $rdata) = del_file(
			"$main::cfg{'APACHE_LOG_DIR'}/$dmn_name-combined.log"
		);
		return $rs if ($rs != 0);
	}

	if (-e "$main::cfg{'APACHE_LOG_DIR'}/$dmn_name-traf.log") {
		($rs, $rdata) = del_file(
			"$main::cfg{'APACHE_LOG_DIR'}/$dmn_name-traf.log"
		);
		return $rs if ($rs != 0);
	}

	push_el(\@main::el, 'dmn_del_httpd_file_data()', 'Ending...');

	0;
}

################################################################################
##
## Add HTTPd Data
##
sub dmn_add_httpd_data {

	push_el(\@main::el, 'dmn_add_httpd_data()', 'Starting...');

	my ($dmn_data) = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_add_httpd_data()', 'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my $rs;

	$rs = dmn_add_httpd_cfg_data($dmn_data);
	return $rs if ($rs != 0);

	$rs = dmn_add_httpd_file_data($dmn_data);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'dmn_add_httpd_data()', 'Ending...');

	0;
}

################################################################################
##
## Change HTTPd Data
##
sub dmn_change_httpd_data {

	push_el(\@main::el, 'dmn_change_httpd_data()', 'Starting...');

	my ($dmn_data) = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_change_httpd_data()',
			'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my $rs;

	$rs = dmn_change_httpd_cfg_data($dmn_data);
	return $rs if ($rs != 0);

	$rs = dmn_change_httpd_file_data($dmn_data);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'dmn_change_httpd_data()', 'Ending...');

	0;
}

################################################################################
##
## Delete HTTPd Data
##
sub dmn_del_httpd_data {

	push_el(\@main::el, 'dmn_del_httpd_data()', 'Starting...');

	my ($dmn_data) = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_del_httpd_data()', 'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my $rs;

	$rs = dmn_del_httpd_cfg_data($dmn_data);
	return $rs if ($rs != 0);

	$rs = dmn_del_httpd_file_data($dmn_data);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'dmn_del_httpd_data()', 'Ending...');

	0;
}

################################################################################
##                             MTA data managment                             ##
################################################################################

################################################################################
##
## Add MTA CFG Data
##
sub dmn_add_mta_cfg_data {

	push_el(\@main::el, 'dmn_add_mta_cfg_data()', 'Starting...');

	my ($dmn_data)   = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_add_mta_cfg_data()',
			'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my ($rs, $rdata, $sys, $working);
	my $dmn_id = @$dmn_data[0];
	my $dmn_name = @$dmn_data[1];
	my $conf_dir = $main::cfg{'CONF_DIR'};
	my $cmd_postmap = $main::cfg{'CMD_POSTMAP'};
	my $tpl_dir = "$conf_dir/postfix/parts";
	my $working_dir = "$conf_dir/postfix/working";
	my $backup_dir = "$conf_dir/postfix/backup";
	my $sys_cfg = $main::cfg{'MTA_VIRTUAL_DMN_HASH'};
	my $working_cfg = "$working_dir/domains";
	my $backup_cfg = "$backup_dir/domains." . time();

	# Getting needed configs;

	($rs, $sys) = get_file($sys_cfg);
	return $rs if ($rs != 0);

	($rs, $working) = get_file($working_cfg);
	return $rs if ($rs != 0);

	# Checking for domain entry existence

	$working =~ s/^$dmn_name\t\t\t[^\n]+\n//gim;

	# Add domain entry only if any email is already added to domain
	if (@$dmn_data[8] < 0) {

		my $sql = "
			SELECT
				`mail_acc`
			FROM
				`mail_users`
			WHERE
				`domain_id` = $dmn_id
			AND
				`sub_id`= 0
			;
		";

		($rs, $rdata) = doSQL($sql);
		return $rs if ($rs != 0);

		my $mail_count = @$rdata;

		if ($mail_count > 0) {
			$working .= "$dmn_name\t\t\tvdmn_entry\n";
		}

	} else {
		$working .= "$dmn_name\t\t\tvdmn_entry\n";
	}

	# Let's do some backup first;

	$rs = store_file(
		$backup_cfg, $sys, $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'},
		0644
	);
	return $rs if ($rs != 0);

	# Let's write configs

	$rs = store_file(
		$working_cfg, $working, $main::cfg{'ROOT_USER'},
		$main::cfg{'ROOT_GROUP'}, 0644
	);
	return $rs if ($rs != 0);

	$rs = store_file(
		$sys_cfg, $working, $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'},
		0644
	);
	return $rs if ($rs != 0);

	$rs = sys_command("$cmd_postmap $sys_cfg");
	return $rs if ($rs != 0);

	# Support for Amavisd local domains map - Begin
	if(defined $main::cfg{'AMAVIS_LOCAL_DOMAINS_HASH'} &&
		-e $main::cfg{'AMAVIS_LOCAL_DOMAINS_HASH'}) {

		# Does backup first
		if(-e $main::cfg{'AMAVIS_LOCAL_DOMAINS_HASH'}) {
			$rs = sys_comand_rs(
				"$main::cfg{CMD_CP} $main::cfg{'AMAVIS_LOCAL_DOMAINS_HASH'} " .
				"$main::cfg{'CONF_DIR'}/amavisd/backup/amavisd.domains" . time
			);
			return $rs if ($rs != 0);
		}

		($rs, $working) = get_file($main::cfg{'AMAVIS_LOCAL_DOMAINS_HASH'});
		return $rs if $rs != 0;

		# Removing entry if already exist
		$working =~ s/$dmn_name\n//;

		# Adding domain entry
		$working .= "$dmn_name\n";

		$rs = store_file(
			$main::cfg{'AMAVIS_LOCAL_DOMAINS_HASH'}, $working,
			$main::cfg{'AMAVIS_USER'}, $main::cfg{'AMAVIS_GROUP'}, 0640
		);
		return $rs if ($rs != 0);
	}
	# Support for Amavisd local domains map - End

	push_el(\@main::el, 'dmn_add_mta_cfg_data()', 'Ending...');

	0;
}

################################################################################
##
## Delete MTA CFG Data
##
sub dmn_del_mta_cfg_data {

	push_el(\@main::el, 'dmn_del_mta_cfg_data()', 'Starting...');

	my ($dmn_data) = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_del_mta_cfg_data()',
			'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my ($rs, $rdata, $sys, $working);
	my $dmn_name = @$dmn_data[1];
	my $conf_dir = $main::cfg{'CONF_DIR'};
	my $cmd_postmap = $main::cfg{'CMD_POSTMAP'};
	my $tpl_dir = "$conf_dir/postfix/parts";
	my $working_dir = "$conf_dir/postfix/working";
	my $backup_dir = "$conf_dir/postfix/backup";
	my $sys_cfg = $main::cfg{'MTA_VIRTUAL_DMN_HASH'};
	my $working_cfg = "$working_dir/domains";
	my $backup_cfg = "$backup_dir/domains." . time();

	# Getting needed configs;

	($rs, $sys) = get_file($sys_cfg);
	return $rs if ($rs != 0);

	($rs, $working) = get_file($working_cfg);
	return $rs if ($rs != 0);

	# Checking for domain entry existance;

	$working =~ s/^$dmn_name\t\t\t[^\n]+\n//gim;

	# Let's do some backup first

	$rs = store_file(
		$backup_cfg, $sys, $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'},
		0644
	);
	return $rs if ($rs != 0);

	# Let's write configs

	$rs = store_file(
		$working_cfg, $working, $main::cfg{'ROOT_USER'},
		$main::cfg{'ROOT_GROUP'}, 0644
	);
	return $rs if ($rs != 0);

	$rs = store_file(
		$sys_cfg, $working, $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'},
		0644
	);
	return $rs if ($rs != 0);

	$rs = sys_command("$cmd_postmap $sys_cfg");
	return $rs if ($rs != 0);

	# Support for Amavisd local domains map - Begin
	if(defined $main::cfg{'AMAVIS_LOCAL_DOMAINS_HASH'} &&
		-e $main::cfg{'AMAVIS_LOCAL_DOMAINS_HASH'}) {

		($rs, $working) = get_file($main::cfg{'AMAVIS_LOCAL_DOMAINS_HASH'});
		return $rs if $rs != 0;

		# Removing domain entry
		$working =~ s/^$dmn_name\n//gim;

		$rs = store_file(
			$main::cfg{'AMAVIS_LOCAL_DOMAINS_HASH'}, $working,
			$main::cfg{'AMAVIS_USER'}, $main::cfg{'AMAVIS_GROUP'}, 0640
		);
		return $rs if ($rs != 0);
	}
	# Support for Amavisd local domains map - End


	push_el(\@main::el, 'dmn_del_mta_cfg_data()', 'Ending...');

	0;
}

################################################################################
##
## Add MTA File Data
##
sub dmn_add_mta_file_data {

	push_el(\@main::el, 'dmn_add_mta_file_data()', 'Starting...');

	my ($dmn_data) = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_add_mta_file_data()',
			'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my ($rs, $rdata);
	my $dmn_name = @$dmn_data[1];
	my $virtual_mail_dir = $main::cfg{'MTA_VIRTUAL_MAIL_DIR'};
	my $mailbox_uid_name = $main::cfg{'MTA_MAILBOX_UID_NAME'};
	my $mailbox_gid_name = $main::cfg{'MTA_MAILBOX_GID_NAME'};

	$rs = makepath(
		"$virtual_mail_dir/$dmn_name", $mailbox_uid_name, $mailbox_gid_name,
		0700
	);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'dmn_add_mta_file_data()', 'Ending...');

	0;
}

################################################################################
##
## Delete MTA File Data
##
sub dmn_del_mta_file_data {

	push_el(\@main::el, 'dmn_del_mta_file_data()', 'Starting...');

	my ($dmn_data) = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_del_mta_file_data()',
			'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my $dmn_name = @$dmn_data[1];
	my $virtual_mail_dir = $main::cfg{'MTA_VIRTUAL_MAIL_DIR'};

	my $rs = del_dir("$virtual_mail_dir/$dmn_name");
	return $rs if ($rs != 0);

	push_el(\@main::el, 'dmn_del_mta_file_data()', 'Ending...');

	0;
}

################################################################################
##
## Add MTA Data
##
sub dmn_add_mta_data {

	push_el(\@main::el, 'dmn_add_mta_data()', 'Starting...');

	my ($dmn_data) = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_add_mta_data()', 'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my $rs;

	$rs = dmn_add_mta_cfg_data($dmn_data);
	return $rs if ($rs != 0);

	$rs = dmn_add_mta_file_data($dmn_data);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'dmn_add_mta_data()', 'Ending...');

	0;
}

################################################################################
##
## Change MTA CFG Data
##
sub dmn_change_mta_data {

	push_el(\@main::el, 'dmn_change_mta_data()', 'Starting...');

	my ($dmn_data) = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_change_mta_data()', 'ERROR: Undefined Input Data...'
		);
		return -1;
	}

	my $rs = dmn_add_mta_data($dmn_data);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'dmn_change_mta_data()', 'Ending...');

	0;
}

################################################################################
##
## Delete MTA CFG Data
##
sub dmn_del_mta_data {

	push_el(\@main::el, 'dmn_del_mta_data()', 'Starting...');

	my ($dmn_data) = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_del_mta_data()', 'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my $rs;

	$rs = dmn_del_mta_cfg_data($dmn_data);
	return $rs if ($rs != 0);

	$rs = dmn_del_mta_file_data($dmn_data);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'dmn_del_mta_data()', 'Ending...');

	0;
}

################################################################################
##                           Crontab data managment                           ##
################################################################################

################################################################################
##
## Add Crontab Data
##
sub dmn_add_crontab_data {

	push_el(\@main::el, 'dmn_add_crontab_data()', 'Starting...');

	my ($dmn_data) = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_add_crontab_data()', 'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my ($rs, $rdata);
	my $dmn_userid = @$dmn_data[0];
	my $dmn_name = @$dmn_data[1];
	my $cronjob_minute = @$dmn_data[2];
	my $cronjob_hour = @$dmn_data[3];
	my $cronjob_day = @$dmn_data[4];
	my $cronjob_month = @$dmn_data[5];
	my $cronjob_dweek = @$dmn_data[6];
	my $cronjob_command = @$dmn_data[7];
	my $cronjob_id = @$dmn_data[8];
	my $conf_dir = $main::cfg{'CONF_DIR'};
	my $log_dir = $main::cfg{'LOG_DIR'};
	my $tpl_dir = "$conf_dir/cron.d/parts";
	my $working_dir = "$conf_dir/cron.d/working";
	my $backup_dir = "$conf_dir/cron.d/backup";
	my $working_cfg = "$working_dir/easyscp";
	my $backup_cfg = "$backup_dir/easyscp." . time();

	# Getting needed templates;

	my ($dt_b, $dt_e, $dmn_custom_b, $dmn_custom_entry, $dmn_custom_e) = (
		'', '', '', '', ''
	);

	(
		$rs, $dt_b, $dt_e, $dmn_custom_b, $dmn_custom_entry, $dmn_custom_e
	) = get_tpl (
		$tpl_dir, 'dt_b.tpl', 'dt_e.tpl', 'dmn_custom_b.tpl',
		'dmn_custom_entry.tpl', 'dmn_custom_e.tpl'
	);
	return $rs if ($rs != 0);

	#
	# Preparing templates;
	#

	my %tag_hash = (
		'{DMN_NAME}' => $dmn_name,
		'{USER}' => $dmn_userid,
		'{MINUTE}' => $cronjob_minute,
		'{HOUR}' => $cronjob_hour,
		'{DAY}' => $cronjob_day,
		'{MONTH}' => $cronjob_month,
		'{DWEEK}' => $cronjob_dweek,
		'{CRONJOB_ID}' => $cronjob_id,
		'{LOG_DIR}' => $log_dir
	);

	my ($dmn_custom_b_val, $dmn_custom_e_val);

	($rs, $dmn_custom_b_val, $dmn_custom_entry, $dmn_custom_e_val) = prep_tpl (
		\%tag_hash, $dmn_custom_b, $dmn_custom_entry, $dmn_custom_e
	);
	return $rs if ($rs != 0);

	# Creating working config data;

	my ($sys, $working);

	($rs, $working) = get_file($working_cfg);
	return $rs if ($rs != 0);

	($rs, $rdata) = get_tag( $dmn_custom_b_val, $dmn_custom_e_val, $working);

	# it is safe to delete because cronjobs are handled by id
	if ($rs == 0) {
		($rs, $working) = del_tag(
			$dmn_custom_b_val, "$dmn_custom_e_val\n", $working
		);
		return $rs if ($rs != 0);
	}

	($rs, $rdata) = get_tag($dmn_custom_b, $dmn_custom_e, $working);
	return $rs if ($rs != 0);

	my $dmn_custom_task = "$dmn_custom_b_val$dmn_custom_entry" .
		"$dmn_custom_e_val\n$dmn_custom_b$dmn_custom_e";

	($rs, $working) = repl_tag(
		$dmn_custom_b, $dmn_custom_e, $working, $dmn_custom_task,
		'dmn_add_crontab_data'
	);
	return $rs if ($rs != 0);

	$rs = store_file(
		$working_cfg, $working, $main::cfg{'ROOT_USER'},
		$main::cfg{'ROOT_GROUP'}, 0644
	);
	return $rs if ($rs != 0);

	# Now we'll proceed system config;

	# BSD/NUX Command
	if ($main::cfg{'ROOT_GROUP'} eq 'wheel') {
		$rs = sys_command_rs(
			"$main::cfg{'CMD_CP'} /var/cron/tabs/root $backup_cfg"
		);
	} else {
		$rs = sys_command_rs(
			"$main::cfg{'CMD_CP'} /etc/cron.d/easyscp $backup_cfg"
		);
	}

	return $rs if ($rs != 0);

	# BSD/NUX Command
	if ($main::cfg{'ROOT_GROUP'} eq 'wheel') {
		$rs = sys_command_rs("$main::cfg{'CMD_CRONTAB'} -u root $working_cfg");
	} else {
		$rs = sys_command_rs(
			"$main::cfg{'CMD_CP'} -f $working_cfg /etc/cron.d/"
		);
	}

	return $rs if ($rs != 0);

	push_el(\@main::el, 'dmn_add_crontab_data()', 'Ending...');

	0;
}

################################################################################
##
## Delete Crontab Data
##
sub dmn_del_crontab_data {

	push_el(\@main::el, 'dmn_del_crontab_data()', 'Starting...');

	my ($dmn_data) = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_del_crontab_data()',
			'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my ($rs, $rdata);
	my $dmn_name = @$dmn_data[1];
	my $cronjob_id = @$dmn_data[2];
	my $conf_dir = $main::cfg{'CONF_DIR'};
	my $log_dir = $main::cfg{'LOG_DIR'};
	my $tpl_dir = "$conf_dir/cron.d/parts";
	my $working_dir = "$conf_dir/cron.d/working";
	my $backup_dir = "$conf_dir/cron.d/backup";
	my $working_cfg = "$working_dir/easyscp";
	my $backup_cfg = "$backup_dir/easyscp." . time();

	# Getting needed templates;

	my ($dt_b, $dt_e, $dmn_custom_b, $dmn_custom_entry, $dmn_custom_e ) = (
		'', '', '', '', ''
	);

	(
		$rs, $dt_b, $dt_e, $dmn_custom_b, $dmn_custom_entry, $dmn_custom_e
	) = get_tpl (
		$tpl_dir, 'dt_b.tpl', 'dt_e.tpl', 'dmn_custom_b.tpl',
		'dmn_custom_entry.tpl', 'dmn_custom_e.tpl'
	);
	return $rs if ($rs != 0);

	# Preparing templates;

	my %tag_hash = (
		'{DMN_NAME}' => $dmn_name,
		'{CRONJOB_ID}' => $dmn_name,
		'{LOG_DIR}' => $log_dir
	);

	my ($dmn_custom_b_val, $dmn_custom_e_val);

	(
		$rs, $dmn_custom_b_val, $dmn_custom_entry, $dmn_custom_e_val
	) = prep_tpl (
		\%tag_hash, $dmn_custom_b, $dmn_custom_entry, $dmn_custom_e
	);
	return $rs if ($rs != 0);

	#
	# Creating working config data;
	#

	my ($sys, $working);

	($rs, $working) = get_file($working_cfg);
	return $rs if ($rs != 0);

	($rs, $rdata) = get_tag($dmn_custom_b_val, $dmn_custom_e_val, $working);

	if ($rs == 0) {
		($rs, $working) = del_tag(
			$dmn_custom_b_val, "$dmn_custom_e_val\n", $working
		);
		return $rs if ($rs != 0);
	}

	($rs, $rdata) = get_tag($dmn_custom_b, $dmn_custom_e, $working);
	return $rs if ($rs != 0);

	$rs = store_file(
		$working_cfg, $working, $main::cfg{'ROOT_USER'},
		$main::cfg{'ROOT_GROUP'}, 0644
	);
	return $rs if ($rs != 0);

	#
	# Now we'll proceed system config;
	#
	# BSD/NUX Command
	if ($main::cfg{'ROOT_GROUP'} eq 'wheel') {
		$rs = sys_command_rs(
			"$main::cfg{'CMD_CP'} /var/cron/tabs/root $backup_cfg"
		);
	} else {
		$rs = sys_command_rs(
			"$main::cfg{'CMD_CP'} /etc/cron.d/easyscp $backup_cfg"
		);
	}

	return $rs if ($rs != 0);

	# BSD/NUX Command
	if ($main::cfg{'ROOT_GROUP'} eq 'wheel') {
		$rs = sys_command_rs(
			"$main::cfg{'CMD_CRONTAB'} -u root $working_cfg"
		);
	} else {
		$rs = sys_command_rs(
			"$main::cfg{'CMD_CP'} -f $working_cfg /etc/cron.d/"
		);
	}

	return $rs if ($rs != 0);

	push_el(\@main::el, 'dmn_del_crontab_data()', 'Ending...');

	0;
}

################################################################################
##
## Add Backup Crontab Data
##
sub dmn_add_bkp_crontab_data {

	push_el(\@main::el, 'dmn_add_bkp_crontab_data()', 'Starting...');

	my ($dmn_data) = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_add_bkp_crontab_data()',
			'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my ($rs, $rdata);
	my $dmn_id = @$dmn_data[0];
	my $dmn_name = @$dmn_data[1];
	my $conf_dir = $main::cfg{'CONF_DIR'};
	my $backup_hour = $main::cfg{'BACKUP_HOUR'};
	my $backup_minute = $main::cfg{'BACKUP_MINUTE'};
	my $backup_root_dir = $main::cfg{'BACKUP_ROOT_DIR'};
	my $log_dir = $main::cfg{'LOG_DIR'};
	my $tpl_dir = "$conf_dir/cron.d/parts";
	my $working_dir = "$conf_dir/cron.d/working";
	my $backup_dir = "$conf_dir/cron.d/backup";
	my $working_cfg = "$working_dir/easyscp";
	my $backup_cfg = "$backup_dir/easyscp." . time;

	#
	# Getting needed templates;
	#
	my ($dt_b, $dt_e, $dmn_bk_b, $dmn_bk_entry, $dmn_bk_e) = (
		'', '', '', '', ''
	);

	(
		$rs, $dt_b, $dt_e, $dmn_bk_b, $dmn_bk_entry, $dmn_bk_e
	) = get_tpl (
		$tpl_dir, 'dt_b.tpl', 'dt_e.tpl', 'dmn_bk_b.tpl', 'dmn_bk_entry.tpl',
		'dmn_bk_e.tpl'
	);
	return $rs if ($rs != 0);

	# Preparing templates;

	my %tag_hash = (
		'{DMN_NAME}' => $dmn_name,
		'{DMN_ID}' => $dmn_id,
		'{MINUTE}' => $backup_minute,
		'{HOUR}' => $backup_hour,
		'{BACKUP_ROOT_DIR}' => $backup_root_dir,
		'{LOG_DIR}' => $log_dir
	);

	my ($dmn_bk_b_val, $dmn_bk_e_val);

	(
		$rs, $dmn_bk_b_val, $dmn_bk_entry, $dmn_bk_e_val
	) = prep_tpl (
		\%tag_hash, $dmn_bk_b, $dmn_bk_entry, $dmn_bk_e
	);
	return $rs if ($rs != 0);

	# Creating working config data;

	my ($sys, $working);

	($rs, $working) = get_file($working_cfg);
	return $rs if ($rs != 0);

	($rs, $rdata) = get_tag( $dmn_bk_b_val, $dmn_bk_e_val, $working);

	if ($rs == 0) {
		# We have one ! We must delete it because of
		# possible future changes in this Domain Group Entry;
		($rs, $working) = del_tag($dmn_bk_b_val, "$dmn_bk_e_val\n", $working);
		return $rs if ($rs != 0);
	}

	($rs, $rdata) = get_tag($dmn_bk_b, $dmn_bk_e, $working);
	return $rs if ($rs != 0);

	my $dmn_bk_task =
		"$dmn_bk_b_val$dmn_bk_entry$dmn_bk_e_val\n$dmn_bk_b$dmn_bk_e";

	($rs, $working) = repl_tag(
		$dmn_bk_b, $dmn_bk_e, $working, $dmn_bk_task, 'dmn_add_bkp_crontab_data'
	);
	return $rs if ($rs != 0);

	$rs = store_file(
		$working_cfg, $working, $main::cfg{'ROOT_USER'},
		$main::cfg{'ROOT_GROUP'}, 0644
	);
	return $rs if ($rs != 0);

	# Now we'll proceed system config;

	# BSD/NUX Command
	if ($main::cfg{'ROOT_GROUP'} eq 'wheel') {
		$rs = sys_command_rs(
			"$main::cfg{'CMD_CP'} /var/cron/tabs/root $backup_cfg"
		);
	} else {
		$rs = sys_command_rs(
			"$main::cfg{'CMD_CP'} /etc/cron.d/easyscp $backup_cfg"
		);
	}

	return $rs if ($rs != 0);

	# BSD/NUX Command
	if ($main::cfg{'ROOT_GROUP'} eq 'wheel') {
		$rs = sys_command_rs("$main::cfg{'CMD_CRONTAB'} -u root $working_cfg");
	} else {
		$rs = sys_command_rs(
			"$main::cfg{'CMD_CP'} -f $working_cfg /etc/cron.d/"
		);
	}

	return $rs if ($rs != 0);

	push_el(\@main::el, 'dmn_add_bkp_crontab_data()', 'Ending...');

	0;
}

################################################################################
##
## Delete Backup Crontab Data
##
sub dmn_del_bkp_crontab_data {

	push_el(\@main::el, 'dmn_del_bkp_crontab_data()', 'Starting...');

	my ($dmn_data) = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_del_bkp_crontab_data()',
			'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my ($rs, $rdata);
	my $dmn_name = @$dmn_data[1];
	my $conf_dir = $main::cfg{'CONF_DIR'};
	my $backup_hour = $main::cfg{'BACKUP_HOUR'};
	my $backup_minute = $main::cfg{'BACKUP_MINUTE'};
	my $backup_root_dir = $main::cfg{'BACKUP_ROOT_DIR'};
	my $log_dir = $main::cfg{'LOG_DIR'};
	my $tpl_dir = "$conf_dir/cron.d/parts";
	my $working_dir = "$conf_dir/cron.d/working";
	my $backup_dir = "$conf_dir/cron.d/backup";
	my $working_cfg = "$working_dir/easyscp";
	my $backup_cfg = "$backup_dir/easyscp." . time;
	#
	# Getting needed templates;
	#
	my (
		$dt_b, $dt_e, $dmn_bk_b, $dmn_bk_entry, $dmn_bk_e
	) = ('', '', '', '', '');
	(
		$rs, $dt_b, $dt_e, $dmn_bk_b, $dmn_bk_entry, $dmn_bk_e
	) = get_tpl (
		$tpl_dir, 'dt_b.tpl', 'dt_e.tpl', 'dmn_bk_b.tpl', 'dmn_bk_entry.tpl',
		'dmn_bk_e.tpl'
	);
	return $rs if ($rs != 0);

	#
	# Preparing templates;
	#
	my %tag_hash = (
		'{DMN_NAME}' => $dmn_name,
		'{MINUTE}' => $backup_minute,
		'{HOUR}' => $backup_hour,
		'{BACKUP_ROOT_DIR}' => $backup_root_dir,
		'{LOG_DIR}' => $log_dir
	);
	my ($dmn_bk_b_val, $dmn_bk_e_val) = (undef, undef);
	(
		$rs, $dmn_bk_b_val, $dmn_bk_entry, $dmn_bk_e_val
	) = prep_tpl (
		\%tag_hash, $dmn_bk_b, $dmn_bk_entry, $dmn_bk_e
	);
	return $rs if ($rs != 0);

	# Creating working config data;

	my ($sys, $working);

	($rs, $working) = get_file($working_cfg);
	return $rs if ($rs != 0);

	($rs, $rdata) = get_tag( $dmn_bk_b_val, $dmn_bk_e_val, $working);

	if ($rs == 0) {
		# We have one ! We must delete it because of possible
		# future changes in this Domain Group Entry;
		($rs, $working) = del_tag($dmn_bk_b_val, "$dmn_bk_e_val\n", $working);
		return $rs if ($rs != 0);
	}

	($rs, $rdata) = get_tag($dmn_bk_b, $dmn_bk_e, $working);
	return $rs if ($rs != 0);

	$rs = store_file(
		$working_cfg, $working, $main::cfg{'ROOT_USER'},
		$main::cfg{'ROOT_GROUP'}, 0644
	);
	return $rs if ($rs != 0);

	#
	# Now we'll proceed system config;
	#
	# BSD/NUX Command
	if ($main::cfg{'ROOT_GROUP'} eq 'wheel') {
		$rs = sys_command_rs(
			"$main::cfg{'CMD_CP'} /var/cron/tabs/root $backup_cfg"
		);
	} else {
		$rs = sys_command_rs(
			"$main::cfg{'CMD_CP'} /etc/cron.d/easyscp $backup_cfg"
		);
	}

	return $rs if ($rs != 0);

	# BSD/NUX Command
	if ($main::cfg{'ROOT_GROUP'} eq 'wheel') {
		$rs = sys_command_rs(
			"$main::cfg{'CMD_CRONTAB'} -u root $working_cfg"
		);
	} else {
		$rs = sys_command_rs(
			"$main::cfg{'CMD_CP'} -f $working_cfg /etc/cron.d/"
		);
	}

	return $rs if ($rs != 0);

	push_el(\@main::el, 'dmn_del_bkp_crontab_data()', 'Ending...');

	0;
}

################################################################################
##                           AWStats data managment                           ##
################################################################################

################################################################################
##
## Add AWStats Data
##
sub dmn_add_awstats_data {

	push_el(\@main::el, 'dmn_add_awstats_data()', 'Starting...');

	my ($dmn_data) = @_;


	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_add_awstats_data()',
			'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my $aws_type = $main::cfg{'AWSTATS_MODE'};


	my $rs;

	$rs = dmn_add_awstats_cfg_data($dmn_data);
	return $rs if ($rs != 0);

	if ($aws_type eq 1) {
		$rs = dmn_add_awstats_cron($dmn_data);
		return $rs if ($rs != 0);
	}

	push_el(\@main::el, 'dmn_add_awstats_data()', 'Ending...');

	0;
}

################################################################################
##
## Add AWStats CFG Data
##
sub dmn_add_awstats_cfg_data {

	push_el(\@main::el, 'dmn_add_awstats_cfg_data()', 'Starting...');

	my ($dmn_data) = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_add_awstats_cfg_data()',
			'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my ($rs, $rdata);
	my $dmn_name = @$dmn_data[1];
	my $conf_dir = $main::cfg{'CONF_DIR'};
	my $awstats_dir = $main::cfg{'AWSTATS_CONFIG_DIR'};
	my $tpl_dir = "$conf_dir/awstats";
	my $awstats_fname = "awstats.$dmn_name.conf";
	my $sys_cfg = "$awstats_dir/$awstats_fname";

	# Let's get needed tags and templates;

	my $entry = '';

	($rs, $entry) = get_tpl($tpl_dir, 'awstats.easyscp_tpl.conf');
	return $rs if ($rs != 0);

	#
	# Let's prepare them;
	#
	my %tag_hash = (
		'{DOMAIN_NAME}' => $dmn_name,
		'{CMD_CAT}' => $main::cfg{'CMD_CAT'},
		'{APACHE_LOG_DIR}' => $main::cfg{'APACHE_LOG_DIR'},
		'{AWSTATS_CACHE_DIR}' => $main::cfg{'AWSTATS_CACHE_DIR'},
		'{AWSTATS_ENGINE_DIR}' => $main::cfg{'AWSTATS_ENGINE_DIR'},
		'{AWSTATS_WEB_DIR}' => $main::cfg{'AWSTATS_WEB_DIR'}
	);

	($rs, $entry) = prep_tpl(\%tag_hash, $entry);
	return $rs if ($rs != 0);

	#
	# Let's store generated data;
	#

	$rs = store_file(
		$sys_cfg, $entry, $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'},
		0644
	);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'dmn_add_awstats_cfg_data()', 'Ending...');

	0;
}

################################################################################
##
## Change AWStats Data
##
sub dmn_change_awstats_data {

	push_el(\@main::el, 'dmn_change_awstats_data()', 'Starting...');

	my ($dmn_data) = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_change_awstats_data()',
			'ERROR: Undefined Input Data...'
		);
		return -1;
	}

	my $aws_type = $main::cfg{'AWSTATS_MODE'};

	my $rs;

	$rs = dmn_add_awstats_cfg_data($dmn_data);
	return $rs if ($rs != 0);

	if ($aws_type eq 1) {
		$rs = dmn_add_awstats_cron($dmn_data);
		return $rs if ($rs != 0);
	}

	push_el(\@main::el, 'dmn_change_awstats_data()', 'Ending...');

	0;
}

################################################################################
##
## Delete AWStats Data
##
sub dmn_del_awstats_data {

	push_el(\@main::el, 'dmn_del_awstats_data()', 'Starting...');

	my ($dmn_data) = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_del_awstats_data()',
			'ERROR: Undefined Input Data...'
		);
		return -1;
	}

	my $aws_type = $main::cfg{'AWSTATS_MODE'};

	my $rs;

	$rs = dmn_del_awstats_cfg_data($dmn_data);
	return $rs if ($rs != 0);

	if ($aws_type eq 1) {
		$rs = dmn_del_awstats_cron($dmn_data);
		return $rs if ($rs != 0);
	}

	push_el(\@main::el, 'dmn_del_awstats_data()', 'Ending...');

	0;
}

################################################################################
##
## Delete AWStats CFG Data
##
sub dmn_del_awstats_cfg_data {

	push_el(\@main::el, 'dmn_del_awstats_cfg_data()', 'Starting...');

	my ($dmn_data) = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_del_awstats_cfg_data()',
			'ERROR: Undefined Input Data...'
		);
		return -1;
	}

	if (-e "$main::cfg{'AWSTATS_CONFIG_DIR'}/awstats@${dmn_data[1]}.conf") {
		my $rs = del_file(
			"$main::cfg{'AWSTATS_CONFIG_DIR'}/awstats@${dmn_data[1]}.conf"
		);
		return $rs if ($rs != 0);
	}

	push_el(\@main::el, 'dmn_del_awstats_cfg_data()', 'Ending...');

	0;
}

################################################################################
##
## Add AWStats Cron Data
##
sub dmn_add_awstats_cron {

	push_el(\@main::el, 'dmn_add_awstats_cron()', 'Starting...');

	my ($dmn_data) = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_add_awstats_cron()',
			'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my ($rs, $rdata, $awstats_b, $awstats_entry, $awstats_e);
	my $dmn_name = @$dmn_data[1];
	my $cronjob_minute = @$dmn_data[0];
	# to prevent running all crons at same time
	$cronjob_minute = $cronjob_minute % 60;
	my $cronjob_hour = '3';
	my $conf_dir = $main::cfg{'CONF_DIR'};
	my $virtual_dir = $main::cfg{'APACHE_WWW_DIR'};
	my $tpl_dir = "$conf_dir/cron.d/parts";
	my $working_dir = "$conf_dir/cron.d/working";
	my $backup_dir = "$conf_dir/cron.d/backup";
	my $working_cfg = "$working_dir/easyscp";
	my $backup_cfg = "$backup_dir/easyscp." . time;
	my $user_lang = 'en';
	my $awstats_root_dir = $main::cfg{'AWSTATS_ROOT_DIR'};
	my $awstats_engine_dir = $main::cfg{'AWSTATS_ENGINE_DIR'};
	my $awstats_web_dir = $main::cfg{'AWSTATS_WEB_DIR'};

	# Selecting user language
	my $user_id = @$dmn_data[4];

	my $sql = "
		SELECT
			`lang`
		FROM
			`user_gui_props`
		WHERE
			`user_id` = $user_id
		;
	";

	($rs, $rdata) = doSQL($sql);

	$rdata = @$rdata[0];
	return $rs if ($rs != 0);

	my %languages = (
		'lang_Albanian' => 'al',
		'lang_Bosnian' => 'ba',
		'lang_Bulgarian' => 'bg',
		'lang_Catalan' => 'ca',
		'lang_ChineseTaiwan' => 'tw',
		'lang_Chinese' => 'cn',
		'lang_Czech' => 'cz',
		'lang_Danish' => 'dk',
		'lang_Dutch' => 'nl',
		'lang_English' => 'en',
		'lang_Estonian' => 'et',
		'lang_Euskara' => 'eu',
		'lang_Finish' => 'fi',
		'lang_FrenchFrance' => 'fr',
		'lang_Galician' => 'gl',
		'lang_GermanAustria' => 'de',
		'lang_GermanGermany' => 'de',
		'lang_GermanSwiss' => 'de',
		'lang_Greek' => 'gr',
		'lang_Hebrew' => 'he',
		'lang_Hungarian' => 'hu',
		'lang_Icelandic' => 'is',
		'lang_Indonesian' => 'id',
		'lang_Italian' => 'it',
		'lang_Japanese' => 'jp',
		'lang_Korean' => 'kr',
		'lang_Latvian' => 'lv',
		'lang_NorwegianNyorsk' => 'nn',
		'lang_NorwegianBokmal' => 'nb',
		'lang_Polish' => 'pl',
		'lang_Portuguese' => 'pt',
		'lang_PortuguesBrazil' => 'br',
		'lang_Romanian' => 'ro',
		'lang_Russian' => 'ru',
		'lang_Serbian' => 'sr',
		'lang_Slovak' => 'sk',
		'lang_Slovenian' => 'si',
		'lang_SpanishArgentina' => 'es',
		'lang_SpanishSpain' => 'es',
		'lang_Swedisch' => 'se',
		'lang_Turkish' => 'tr',
		'lang_Ukrainian' => 'ua',
		'lang_Welsh' => 'cy'
	);

	while ( my ($key, $value) = each(%languages) ) {
		if ($key eq @$rdata[0]) {
			$user_lang = $value;
			last;
		}
	}

	# Getting needed templates;

	my ($dmn_awstats_b, $dmn_awstats_entry, $dmn_awstats_e) = ('', '', '');

	($rs, $dmn_awstats_b, $dmn_awstats_entry, $dmn_awstats_e) = get_tpl(
		$tpl_dir, 'dmn_awstats_b.tpl', 'dmn_awstats_entry.tpl',
		'dmn_awstats_e.tpl'
	);
	return $rs if ($rs != 0);

	#
	# Preparing templates;
	#
	my %tag_hash = (
		'{DMN_NAME}' => $dmn_name,
		'{MINUTE}' => $cronjob_minute,
		'{HOUR}' => $cronjob_hour,
		'{AWSTATS_ROOT_DIR}' => $awstats_root_dir,
		'{AWSTATS_ENGINE_DIR}' => $awstats_engine_dir,
		'{AWSTATS_WEB_DIR}' => $awstats_web_dir,
		'{USER_LANG}' => $user_lang,
		'{APACHE_WWW_DIR}' => $virtual_dir
	);

	($rs, $awstats_b, $awstats_entry, $awstats_e) = prep_tpl (
		\%tag_hash, $dmn_awstats_b, $dmn_awstats_entry, $dmn_awstats_e
	);
	return $rs if ($rs != 0);

	# Creating working config data;

	my $working;

	($rs, $working) = get_file($working_cfg);
	return $rs if ($rs != 0);

	($rs, $rdata) = get_tag($awstats_b, $awstats_e, $working);

	if ($rs == 0) {
		# We have one! We have to delete it because of possible future
		# changes in this Domain Group entry;
		($rs, $working) = del_tag($awstats_b, "$awstats_e\n", $working);
		return $rs if ($rs != 0);
	}

	($rs, $rdata) = get_tag($dmn_awstats_b, $dmn_awstats_e, $working);
	return $rs if ($rs != 0);

	my $dmn_awstats_task =
		"$awstats_b\n$awstats_entry\n$awstats_e\n$dmn_awstats_b\n$dmn_awstats_e";

	($rs, $working) = repl_tag(
		$dmn_awstats_b, $dmn_awstats_e, $working, $dmn_awstats_task,
		'dmn_add_awstats_cron'
	);
	return $rs if ($rs != 0);

	$rs = store_file(
		$working_cfg, $working, $main::cfg{'ROOT_USER'},
		$main::cfg{'ROOT_GROUP'}, 0644
	);
	return $rs if ($rs != 0);

	# Now we'll proceed system config;

	# BSD/NUX Command
	if ($main::cfg{'ROOT_GROUP'} eq 'wheel') {
		$rs = sys_command_rs(
			"$main::cfg{'CMD_CP'} /var/cron/tabs/root $backup_cfg"
		);
	} else {
		$rs = sys_command_rs(
			"$main::cfg{'CMD_CP'} /etc/cron.d/easyscp $backup_cfg"
		);
	}

	return $rs if ($rs != 0);

	# BSD/NUX Command
	if ($main::cfg{'ROOT_GROUP'} eq "wheel") {
		$rs = sys_command_rs("$main::cfg{'CMD_CRONTAB'} -u root $working_cfg");
	} else {
		$rs = sys_command_rs("$main::cfg{'CMD_CP'} -f $working_cfg /etc/cron.d/");
	}

	return $rs if ($rs != 0);

	push_el(\@main::el, 'dmn_add_awstats_cron()', 'Ending...');

	0;
}

################################################################################
##
## Delete AWStats Cron Data
##
sub dmn_del_awstats_cron {

	push_el(\@main::el, 'dmn_del_awstats_cron()', 'Starting...');

	my ($dmn_data) = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_del_awstats_cron()',
			'ERROR: Undefined Input Data...'
		);
		return -1;
	}

	my ($rs, $awstats_b, $awstats_e) = (undef, '', '', '');
	my $dmn_name = @$dmn_data[1];
	my $cronjob_minute = @$dmn_data[0];
	# to prevent running all crons at same time
	$cronjob_minute = $cronjob_minute % 60;
	my $cronjob_hour = '3';
	my $conf_dir = $main::cfg{'CONF_DIR'};
	my $tpl_dir = "$conf_dir/cron.d/parts";
	my $working_dir = "$conf_dir/cron.d/working";
	my $backup_dir = "$conf_dir/cron.d/backup";
	my $working_cfg = "$working_dir/easyscp";
	my $backup_cfg = "$backup_dir/easyscp." . time;

	#
	# Getting needed templates;
	#
	my ($dmn_awstats_b, $dmn_awstats_entry, $dmn_awstats_e) = ('', '', '');

	($rs, $dmn_awstats_b, $dmn_awstats_e) = get_tpl(
		$tpl_dir, 'dmn_awstats_b.tpl', 'dmn_awstats_e.tpl'
	);
	return $rs if ($rs != 0);

	# Preparing templates;

	my %tag_hash = ('{DMN_NAME}' => $dmn_name);

	($rs, $awstats_b, $awstats_e) = prep_tpl (
		\%tag_hash, $dmn_awstats_b,$dmn_awstats_e
	);
	return $rs if ($rs != 0);

	# Creating working config data;

	my ($sys, $working, $rdata);

	($rs, $working) = get_file($working_cfg);
	return $rs if ($rs != 0);

	($rs, $rdata) = get_tag($awstats_b, $awstats_e, $working);

	push_el(\@main::el, 'dmn_del_awstats_cron() search', $awstats_b);

	if ($rs == 0) {
		# We have one! We have to delete it
		($rs, $working) = del_tag($awstats_b, "$awstats_e\n", $working);

		push_el(\@main::el, 'dmn_del_awstats_cron() del', $awstats_b);

		return $rs if ($rs != 0);
	}

	($rs, $rdata) = get_tag($dmn_awstats_b, $dmn_awstats_e, $working);

	push_el(\@main::el, 'dmn_del_awstats_cron() search', $dmn_awstats_b);

	return $rs if ($rs != 0);

	$rs = store_file(
		$working_cfg, $working, $main::cfg{'ROOT_USER'},
		$main::cfg{'ROOT_GROUP'}, 0644
	);
	return $rs if ($rs != 0);

	# Now we'll proceed system config

	# BSD/NUX Command
	if ($main::cfg{'ROOT_GROUP'} eq "wheel") {
		$rs = sys_command_rs(
			"$main::cfg{'CMD_CP'} /var/cron/tabs/root $backup_cfg"
		);
	} else {
		$rs = sys_command_rs(
			"$main::cfg{'CMD_CP'} /etc/cron.d/easyscp $backup_cfg"
		);
	}

	return $rs if ($rs != 0);

	# BSD/NUX Command
	if ($main::cfg{'ROOT_GROUP'} eq "wheel") {
		$rs = sys_command_rs(
			"$main::cfg{'CMD_CRONTAB'} -u root $working_cfg"
		);
	} else {
		$rs = sys_command_rs(
			"$main::cfg{'CMD_CP'} -f $working_cfg /etc/cron.d/"
		);
	}

	return $rs if ($rs != 0);

	push_el(\@main::el, 'dmn_del_awstats_cron()', 'Ending...');

	0;
}

################################################################################
##                            High level subroutines                          ##
################################################################################

################################################################################
##
## Add Domain Data
##
sub dmn_add_data {

	push_el(\@main::el, 'dmn_add_data()', 'Starting...');

	my ($dmn_data) = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_add_data()', 'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my $rs;
	my $awstats = $main::cfg{'AWSTATS_ACTIVE'};

	# check whether AWStats is enabled
	if ($awstats ne 'no') {
		$rs = dmn_add_awstats_data($dmn_data);
		return $rs if ($rs != 0);
	}

	$rs = dmn_add_named_data($dmn_data);
	return $rs if ($rs != 0);

	$rs = dmn_add_httpd_data($dmn_data);
	return $rs if ($rs != 0);

	# Fix for ticket #2388
	# Must be done here to ensure availibility of required domain gid
	$rs = _add_customer_master_dmn_als_db_data($dmn_data);
	return $rs if ($rs != 0);

	$rs = dmn_add_mta_data($dmn_data);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'dmn_add_data()', 'Ending...');

	0;
}

################################################################################
##
## Change Domain Data
##
sub dmn_change_data {

	push_el(\@main::el, 'dmn_change_data()', 'Starting...');

	my ($dmn_data) = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_change_data()', 'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my $rs;
	my $awstats = $main::cfg{'AWSTATS_ACTIVE'};

	# check whether AWStats is enabled
	if ($awstats ne 'no') {
		$rs = dmn_change_awstats_data($dmn_data);
		return $rs if ($rs != 0);
	}

	$rs = dmn_change_named_data($dmn_data);
	return $rs if ($rs != 0);

	$rs = dmn_change_httpd_data($dmn_data);
	return $rs if ($rs != 0);

	$rs = dmn_change_mta_data($dmn_data);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'dmn_change_data()', 'Ending...');

	0;
}

################################################################################
##
## Delete Domain Data
##
sub dmn_del_data {

	push_el(\@main::el, 'dmn_del_data()', 'Starting...');

	my ($dmn_data) = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(\@main::el, 'dmn_del_data()', 'ERROR: Undefined Input Data...');
		return -1;
	}

	my $rs;
	my $awstats = $main::cfg{'AWSTATS_ACTIVE'};

	# check whether AWStats is enabled
	if ($awstats ne 'no') {
		$rs = dmn_del_awstats_data($dmn_data);
		return $rs if ($rs != 0);
	}

	$rs = dmn_del_named_data($dmn_data);
	return $rs if ($rs != 0);

	$rs = dmn_del_httpd_data($dmn_data);
	return $rs if ($rs != 0);

	$rs = dmn_del_mta_data($dmn_data);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'dmn_del_data()', 'Ending...');

	0;
}

################################################################################
##
## Restore backups Data (domain files and databases) for one domain
##
## Note: For each database restoration, the restored database and a least one
## login credentials linked to it must exists. Otherwise, the database will not
## restored.
##
sub dmn_restore_data {

	push_el(\@main::el, 'dmn_restore_data()', 'Starting...');

	my ($data) = @_;

	if(!defined($data) || $data eq '') {
		push_el(
			\@main::el, 'dmn_restore_data()', 'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my $rs;
	my ($dmn_id, $dmn_name, $dmn_uid) = (@$data[0], @$data[1], @$data[3]);

	my $dmn_dir = "$main::cfg{'APACHE_WWW_DIR'}/$dmn_name";
	my $dmn_bk_dir = "$dmn_dir/backups";

	$rs = opendir(DIR, $dmn_bk_dir);

	if(!$rs) {
		push_el(
			\@main::el, 'dmn_restore_data()',
			"ERROR: Can't open '$dmn_bk_dir' directory!"
		);

		return -1;
	}

	my @bk_files = readdir(DIR);
	closedir(DIR);

	return 0 if (@bk_files == 0);

	foreach (@bk_files) {

		# Restore SQL databases
		if(/^(.+?)\.sql\.(bz2|gz|lzma|xz)$/) {

			# Get database login credentials
			my $sql = "
				SELECT
					`sqlu_name`, `sqlu_pass`
				FROM
					`sql_user`, `sql_database`
				WHERE
					`sql_user`.`sqld_id` = `sql_database`.`sqld_id`
				AND
					`sql_database`.`domain_id` = $dmn_id
				AND
					`sql_database`.`sqld_name` = " . $main::db->quote($1) . "
				LIMIT
					1
				;
			";

			my $rdata;

			($rs, $rdata) = doSQL($sql);
			return $rs if ($rs != 0);

			if(@$rdata > 0) {

				# All doubles quotes in the following variables must be escaped
				# to be able to use them in system commands
				map { s/"/\\"/g }
					my $dbuser = @$rdata[0]->[0],
					my $dbpass = decrypt_db_password(@$rdata[0]->[1]),
					my $dbname = $1,
					$_ = $_;

				my $cmd;

				if($2 eq 'bz2') {
					$cmd = qq!$main::cfg{'CMD_BZCAT'} -d "$dmn_bk_dir/$_"!;
				} elsif($2 eq 'gz') {
					$cmd = qq!$main::cfg{'CMD_GZCAT'} -d "$dmn_bk_dir/$_"!;
				} elsif($2 eq 'lzma') {
					$cmd = qq!$main::cfg{'CMD_LZMA'} -dc "$dmn_bk_dir/$_"!;
				} elsif($2 eq 'xz') {
					$cmd = qq!$main::cfg{'CMD_XZ'} -dc "$dmn_bk_dir/$_"!;
				}

				$cmd .=  qq! | $main::cfg{'CMD_MYSQL'} --user="$dbuser"! .
					qq! --password="$dbpass" --database="$dbname"!;

				$rs = sys_command_rs($cmd);
				return $rs if ($rs != 0);
			}
		} elsif(/^.+?\.tar\.(bz2|gz|lzma|xz)$/) { # Restore dmn files

			my $archType;

			if($1 eq 'bz2') {
				$archType = 'bzip2';
			} elsif($1 eq 'gz') {
				$archType = 'gzip';
			} else { # lzma | xz
				$archType = $1;
			}

			my $cmd = "$main::cfg{'CMD_TAR'} -x -p --$archType -C '$dmn_dir' " .
				"-f $dmn_bk_dir/$_";

			$rs = sys_command($cmd);
			return $rs if ($rs != 0);

			$cmd = "$main::cfg{'CMD_CHOWN'} -R $dmn_uid:$main::cfg{'APACHE_GROUP'} $dmn_dir";
			$rs = sys_command($cmd);
			return $rs if ($rs != 0);

			$cmd = "$main::cfg{'CMD_CHOWN'} -R $main::cfg{'ROOT_USER'}:$main::cfg{'ROOT_GROUP'} $dmn_dir/backups";
			$rs = sys_command($cmd);
			#return $rs if ($rs != 0);

			$cmd = "$main::cfg{'CMD_CHOWN'} -R $dmn_uid:$dmn_uid $dmn_dir/cgi-bin";
			$rs = sys_command($cmd);
			return $rs if ($rs != 0);

			$cmd = "$main::cfg{'CMD_CHOWN'} -R $main::cfg{'APACHE_GROUP'}:$main::cfg{'APACHE_GROUP'} $dmn_dir/disabled";
			$rs = sys_command($cmd);
			return $rs if ($rs != 0);

			$cmd = "$main::cfg{'CMD_CHOWN'} -R $dmn_uid:$dmn_uid $dmn_dir/errors";
            $rs = sys_command($cmd);
			return $rs if ($rs != 0);

			$cmd = "$main::cfg{'CMD_CHOWN'} -R $dmn_uid:$dmn_uid $dmn_dir/htdocs";
			$rs = sys_command($cmd);
			return $rs if ($rs != 0);

			$cmd = "$main::cfg{'CMD_CHOWN'} -R $dmn_uid:$main::cfg{'APACHE_GROUP'} $dmn_dir/logs";
            $rs = sys_command($cmd);
			return $rs if ($rs != 0);

			$cmd = "$main::cfg{'CMD_CHOWN'} -R $dmn_uid:$main::cfg{'APACHE_GROUP'} $dmn_dir/phptmp";
			$rs = sys_command($cmd);
			return $rs if ($rs != 0);

			$cmd = 'find '."$dmn_dir/backups".' -type d -print0 | xargs -r -0 '.$main::cfg{'CMD_CHMOD'}.' 0755';
			$rs = sys_command($cmd);
			#return $rs if ($rs != 0);

			$cmd = 'find '."$dmn_dir/backups".' -type f -print0 | xargs -r -0 '.$main::cfg{'CMD_CHMOD'}.' 0444';
			$rs = sys_command($cmd);
			#return $rs if ($rs != 0);

			$cmd = 'find '."$dmn_dir".' -type f -print0 | xargs -r -0 '.$main::cfg{'CMD_CHOWN'}.' '.$main::cfg{'ROOT_USER'}.':'.$main::cfg{'ROOT_GROUP'};
			$rs = sys_command($cmd);
			#return $rs if ($rs != 0);

			$cmd = 'find '."$dmn_dir".' -type f -print0 | xargs -r -0 '.$main::cfg{'CMD_CHMOD'}.' 0644';
			$rs = sys_command($cmd);
			#return $rs if ($rs != 0);
		}
	}

	push_el(\@main::el, 'dmn_restore_data()', 'Ending...');

	0;
}

################################################################################
##
## Enable Domain
##
sub dmn_enable_data {

	push_el(\@main::el, 'dmn_enable_data()', 'Starting...');

	my ($dmn_data) = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_enable_data()', 'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my ($rs, $cmd);

	# Disable disabled htdocs skel
	$cmd= "$main::cfg{'CMD_MV'} $main::cfg{'APACHE_WWW_DIR'}/@${dmn_data[1]}/" .
		"htdocs $main::cfg{'APACHE_WWW_DIR'}/@${dmn_data[1]}/disabled";

	$rs = sys_command($cmd);
	return $rs if ($rs != 0);

	# Enable domain htdocs
 	$cmd = "$main::cfg{'CMD_MV'} $main::cfg{'APACHE_WWW_DIR'}/@${dmn_data[1]}/" .
 	    "htdocs.disabled $main::cfg{'APACHE_WWW_DIR'}/@${dmn_data[1]}/htdocs";

	$rs = sys_command($cmd);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'dmn_enable_data()', 'Ending...');

	0;
}

################################################################################
##
## Disable Domain
##
sub dmn_disable_data {

	push_el(\@main::el, 'dmn_disable_data()', 'Starting...');

	my ($dmn_data) = @_;

	if (!defined($dmn_data) || $dmn_data eq '') {
		push_el(
			\@main::el, 'dmn_disable_data()', 'ERROR: Undefined Input Data...'
		);

		return -1;
	}

	my ($rs, $cmd);

	# Disable htdocs
	$cmd= "$main::cfg{'CMD_MV'} $main::cfg{'APACHE_WWW_DIR'}/@${dmn_data[1]}/" .
		"htdocs $main::cfg{'APACHE_WWW_DIR'}/@${dmn_data[1]}/htdocs.disabled";

	$rs = sys_command($cmd);
	return $rs if ($rs != 0);

	# Enable disabled htdocs skel
	$cmd = "$main::cfg{'CMD_MV'} $main::cfg{'APACHE_WWW_DIR'}/@${dmn_data[1]}/" .
		"disabled $main::cfg{'APACHE_WWW_DIR'}/@${dmn_data[1]}/htdocs";

	$rs = sys_command($cmd);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'dmn_disable_data()', 'Ending...');

	0;
}

################################################################################
##                               Engine function                              ##
################################################################################

################################################################################
##
## Domain Manager Engine
##
sub dmn_mngr_engine {

	push_el(\@main::el, 'dmn_mngr_engine()', 'Starting...');

	my ($rs, $rows, $sql);

	$sql = "
		SELECT
			`t1`.`domain_id`, `t1`.`domain_name`, `t1`.`domain_gid`,
			`t1`.`domain_uid`, `t1`.`domain_admin_id`, `t1`.`domain_created_id`,
			`t1`.`domain_created`, `t1`.`domain_last_modified`,
			`t1`.`domain_mailacc_limit`, `t1`.`domain_ftpacc_limit`,
			`t1`.`domain_traffic_limit`, `t1`.`domain_sqld_limit`,
			`t1`.`domain_sqlu_limit`, `t1`.`domain_status`,
			`t1`.`domain_alias_limit`, `t1`.`domain_subd_limit`,
			`t1`.`domain_ip_id`, `t1`.`domain_disk_limit`,
			`t1`.`domain_disk_usage`, `t1`.`domain_php`, `t1`.`domain_cgi`,
			`t2`.`ip_number`
		FROM
			`domain` AS `t1`,
			`server_ips` AS `t2`
		WHERE
			`t1`.`domain_ip_id` = `t2`.`ip_id`
		AND
			`t1`.`domain_id` = $main::dmn_task_id
		;
	";

	($rs, $rows) = doSQL($sql);
	return $rs if ($rs != 0);

	my $entry = @$rows[0];
	my ($dmn_status, $dmn_id, $dmn_admin_id) = (
		@$entry[13], @$entry[0], @$entry[4]
	);

	my ($sub_name, $msg);

	if ($dmn_status eq 'toadd') {

		# Adds domain data
		$rs = dmn_add_data($entry);

		if ($rs == 0) {
			$sql = "
				UPDATE
					`domain`
				SET
					`domain_status` = 'ok'
				WHERE
					`domain_id` = $dmn_id
				;
			";
		} else {
			($sub_name, $msg) = split(/$main::el_sep/, pop_el(\@main::el));
			$msg =~ s/\'/\\\'/g;

			$sql = "
				UPDATE
					`domain`
				SET
					`domain_status` = '$sub_name | $msg'
				WHERE
					`domain_id` = $dmn_id
				;
			";
		}

	} elsif ($dmn_status eq 'change') {

		# Changes domain data;
		$rs = dmn_change_data($entry);

		if ($rs == 0) {
			$sql = "
				UPDATE
					`domain`
				SET
					`domain_status` = '$main::after_change_status'
				WHERE
					`domain_id` = $dmn_id
				;
			";
		} else {

			($sub_name, $msg) = split(/$main::el_sep/, pop_el(\@main::el));
			$msg =~ s/\'/\\\'/g;

			$sql = "
				UPDATE
					`domain`
				SET
					`domain_status` = '$sub_name | $msg'
				WHERE
					`domain_id` = $dmn_id
				;
			";
		}

	} elsif ($dmn_status eq 'dnschange'){

		# Adds custom DNS entry
		$rs = _dmn_add_named_db_data($entry);

		if ($rs == 0) {
			$sql = "
				UPDATE
					`domain`
				SET
					`domain_status` = 'ok'
				WHERE
					`domain_id` = $dmn_id
				;
			";
		} else {
			($sub_name, $msg) = split(/$main::el_sep/, pop_el(\@main::el));
			$msg =~ s/\'/\\\'/g;

			$sql = "
				UPDATE
					`domain`
				SET
					`domain_status` = '$sub_name | $msg'
				WHERE
					`domain_id` = $dmn_id
				;
			";
		}

	} elsif ($dmn_status eq 'delete') {

		# Deletes domain name
		$rs = dmn_del_data($entry);

		if ($rs == 0) {
			$sql = "
				DELETE FROM
					`domain`
				WHERE
					`domain_id` = $dmn_id
				;
			";

			($rs, undef) = doSQL($sql);
			return $rs if ($rs != 0);

			$sql = "
				DELETE FROM
					`admin`
				WHERE
					`admin_id` = $dmn_admin_id
				;
			";
		} else {
			($sub_name, $msg) = split(/$main::el_sep/, pop_el(\@main::el));
			$msg =~ s/\'/\\\'/g;

			$sql = "
				UPDATE
					`domain`
				SET
					`domain_status` = '$sub_name | $msg'
				WHERE
					`domain_id` = $dmn_id
				;
			";
		}

	} elsif ($dmn_status eq 'restore') {

		# Restore domain data
		$rs = dmn_restore_data($entry);

		if ($rs == 0) {
			$sql = "
				UPDATE
					`domain`
				SET
					`domain_status` = 'ok'
				WHERE
					`domain_id` = $dmn_id
				;
			";
		} else {
			($sub_name, $msg) = split(/$main::el_sep/, pop_el(\@main::el));
			$msg =~ s/\'/\\\'/g;

			$sql = "
				UPDATE
					`domain`
				SET
					`domain_status` = '$sub_name | $msg'
				WHERE
					`domain_id` = $dmn_id
				;
			";
		}

	} elsif ($dmn_status eq 'toenable') {

		# Reactivate domain name
		$rs = dmn_enable_data($entry);

		if ($rs == 0) {
			$sql = "
				UPDATE
					`domain`
				SET
					`domain_status` = 'ok'
				WHERE
					`domain_id` = $dmn_id
				;
			";
		} else {
			($sub_name, $msg) = split(/$main::el_sep/, pop_el(\@main::el));
			$msg =~ s/\'/\\\'/g;

			$sql = "
				UPDATE
					`domain`
				SET
					`domain_status` = '$sub_name | $msg'
				WHERE
					`domain_id` = $dmn_id
				;
			";
		}

	} elsif ($dmn_status eq 'todisable') {

		# Deactivate domain name;
		$rs = dmn_disable_data($entry);

		if ($rs == 0) {
			$sql = "
				UPDATE
					`domain`
				SET
					`domain_status` = 'disabled'
				WHERE
					`domain_id` = $dmn_id
				;
			";
		} else {
			($sub_name, $msg) = split(/$main::el_sep/, pop_el(\@main::el));
			$msg =~ s/\'/\\\'/g;

			$sql = "
				UPDATE
					`domain`
				SET
					`domain_status` = '$sub_name | $msg'
				WHERE
					`domain_id` = $dmn_id
				;
			";
		}
	}

	# Do SQL query
	($rs, undef) = doSQL($sql);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'dmn_mngr_engine()', 'Ending...');

	0;
}

################################################################################
##                               MAIN PROGRAM                                 ##
################################################################################

my $rs;

$rs = dmn_mngr_start_up();

if ($rs != 0) {
	dump_el(\@main::el, $main::easyscp_dmn_mngr_el);
	dmn_mngr_shut_down();

	exit 1;
}

$rs = dmn_mngr_engine();

if ($rs != 0) {
	dump_el(\@main::el, $main::easyscp_dmn_mngr_el);
	dmn_mngr_shut_down();

	exit 1;
}

$rs = dmn_mngr_shut_down();

if ($rs != 0) {
	dump_el(\@main::el, $main::easyscp_dmn_mngr_el);

	exit 1;
}

exit 0;
